
we need a root folder, under this root generated by angular it is composed of: 
1. component folder `ng generate component component/xxx`
2. service folder `ng generate service services/xxx` 
3. common folder contains all classes  `ng generate class common/xxx`

therefore we need to 
1. create angular project 

```shell
ng new food-app
? Which stylesheet format would you like to use? CSS
CREATE food-app/angular.json (3051 bytes)
CREATE food-app/package.json (1072 bytes)
CREATE food-app/README.md (1053 bytes)
CREATE food-app/tsconfig.json (863 bytes)
CREATE food-app/.editorconfig (274 bytes)
CREATE food-app/.gitignore (548 bytes)
CREATE food-app/.browserslistrc (600 bytes)
CREATE food-app/karma.conf.js (1425 bytes)
CREATE food-app/tsconfig.app.json (287 bytes)
CREATE food-app/tsconfig.spec.json (333 bytes)
CREATE food-app/.vscode/extensions.json (130 bytes)
CREATE food-app/.vscode/launch.json (474 bytes)
CREATE food-app/.vscode/tasks.json (938 bytes)
CREATE food-app/src/favicon.ico (948 bytes)
CREATE food-app/src/index.html (293 bytes)
CREATE food-app/src/main.ts (372 bytes)
CREATE food-app/src/polyfills.ts (2338 bytes)
CREATE food-app/src/styles.css (80 bytes)
CREATE food-app/src/test.ts (745 bytes)
CREATE food-app/src/assets/.gitkeep (0 bytes)
CREATE food-app/src/environments/environment.prod.ts (51 bytes)
CREATE food-app/src/environments/environment.ts (658 bytes)
CREATE food-app/src/app/app.module.ts (314 bytes)
CREATE food-app/src/app/app.component.html (23332 bytes)
CREATE food-app/src/app/app.component.spec.ts (962 bytes)
CREATE food-app/src/app/app.component.ts (212 bytes)
CREATE food-app/src/app/app.component.css (0 bytes)

```
add boostrap starter template 

```html

<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    <title>Hello, world!</title>
  </head>
  <body>
    <h1>Hello, world!</h1>
 
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
 
  </body>
</html>
```

get rid of everything inside the app.component.css 


```shell
ng serve --save 

```
 


2. create component for food list 
```shell
ng generate component components/food-list
```


let's add this app-food-list to our app.component.ts to make use of this selector , we have plugged in our new component that we just created 





3. develop typescript class for food, we place this in sub directory 
```shell
food-app>ng generate class common/food
CREATE src/app/common/food.spec.ts (146 bytes)
CREATE src/app/common/food.ts (22 bytes)
```

it is a basic class and nothing is there, we need to add our properties 
we need to add all the things match to our json back from the string boot service 
```TS
export class Food {

    foodName :string;
    foodDescription :string;
    image_url : string;
    price : number;
    stock : number;
    dateCreated :  Date;
    quantity : 0;
}


```

this has to match the actual JSON data coming back to that string data REST API 




4. crate angular service to call REST APIs

```shell
ng generate service services/product

```

then we can move one step forward to create service 
angular service is code developed in typescript, the service is a helper class that provides desired functionality. it is part of my angular app and runs in the web browser client-side. Think of angular service just as java spring service. It is a reusable class or helper class that runs a part of my angular app. 

our angular project has the GUI components ---- multiple service <--REST API--> spring boot backend <-> MySQL


angular privdes the REST client which is called *HttpClient* which is the part of HttpClientModule and we need to add suport in the application module 

our service can be injectaed into other classes/components, this is the dependency injection framwork which is not specific to any particular project or component 

```TS
import {Injectable } from '@angular/core';
import {HttpClient} from '@angular/common/http';

@Injectable({
  providedIn:"root"
})

export class xxxService {
  private baseUrl = "my_exposed_api";

  constructor(private httpClient:HttpClient) {}

}

```
this grabs json data, unwrap it and pull it apart and placing that data into an array of products 


we need to make updates to our app.module.ts 
in the import section, we need to import HttpClientModule 
We need to add provider xxxService 

```TS
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { FoodListComponent } from './components/food-list/food-list.component';
import { FoodService } from './services/food.service';
import { HttpClientModule } from '@angular/common/http';
@NgModule({
  declarations: [
    AppComponent,
    FoodListComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule
  ],
  providers: [FoodService],
  bootstrap: [AppComponent]
})
export class AppModule { }


```




5. update angular component to subscribe to data from angular service
in the component class we will get this list of food and inject the service in the ngOnInit() 


```TS
import {Component, OnInit } from '@angular/core';
import {FoodService} from "../xx/service";
import {Food} from '../xx/food';

@Component{
  selector: '';
  templateUrl : './xxx.component.html',
  styleUrls : ['./xxx.component.css']
}
export class xxxListComponent implements OnInit{
  foods : Food[];
  constructor(private foodService: FoodService){}
 
 ngOnInit(){
   this.listFoods();
 }
 listFoods(){
   this.foodService.getFoodList().subscribe(data => {this.foods = data})
 }


}


```

I will assign results to the array after the method is invoked once I subscribe the json 


```TS

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import {map} from 'rxjs/operators';
import { Food } from '../common/food';
import { Inject } from '@angular/core';


@Injectable({
  providedIn: 'root'
})

export class FoodService {

  private baseUrl = "http://127.0.0.1:8012/food";

  // behind the scene is the injectable 
  constructor(private  httpClient : HttpClient ) { }


 // this returns an obsevable map the json data from spring data REST to foood array 
  getFoodList(): Observable<Food[]>{

        return this.httpClient.get<GetResponse>(this.baseUrl).pipe(
          map(response => response._embedded.foods)
        );


  }
}

// adding supporting interface at the bottom 
// this helps us to unwrap the json from spring data REST _embedded entry 
interface GetResponse{
  _embedded:{
    foods: Food[];
  }
}

```
We grabbed the json data, unwrapped it according and make it available as an array of foods 


let's move over to our component 
we want to inject the Service dependency using foodService 

```ts 

import { Component, OnInit } from '@angular/core';
import { Food } from 'src/app/common/food';
import { FoodService } from 'src/app/services/food.service';

@Component({
  selector: 'app-food-list',
  templateUrl: './food-list.component.html',
  styleUrls: ['./food-list.component.css']
})
export class FoodListComponent implements OnInit {

  foods : Food[];

  constructor(private foodService : FoodService) { }

  // similar to @PostContruct in spring 
  ngOnInit(): void {
    this.listFood();
  }

  listFood(){
    this.foodService.getFoodList().subscribe(
      data => {
        this.foods = data;
      }
    )
  }

}

```

nothing shows up because of the CrossOrigin policy, that is the common pitfall with building full stack apps 



the origin is more than just the host name
origin is protocol + hostname + port 
all of these have to match for it to be the same origin 



```java

package com.carleton.food.repositories;

import com.carleton.food.models.Food;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;
import org.springframework.web.bind.annotation.CrossOrigin;


@CrossOrigin("http://localhost:4200/")
@RepositoryRestResource(collectionResourceRel = "food", path = "food")
public interface FoodRepository extends JpaRepository<Food, Long> {
}

```

let's test out 


6. display the data in an html page 
```html
<p *ngFor="let item of foods">
{{item.attribute}}

  </p>

```

7. add CrossOrign support to angular app 

by default this code will fail so we need to add CrossOrign support to spring boot 
web browser will not allow us to call APIs that are not on the same origin 
it is known as same origin policy, the browser will have security issues with any calls I attempt to make 

same-origin is composed of : scheme/protocol, hostname, post number 
even we are on the same machine, we have different http://localhost:8080 or 4200 and they are not the same origins 
note, this CrossOrigin only applies to the restrictiosn are specific to scripts running in a web browser aka javascript 

but we can relax this by adding cross origin resource sharing CORS on server side application 

in our spring application 


```java
@CrossOrigin("http://localhost:4200","another_server")
// this is the angular default port 
public interface xxRepsoitory extends JpaRepository<T, Long>{
  
}

```
this allows javascript code running on 4200 and accepts calls from web brwoser script from this origin scheme/protocol + host+ port 
and we support multiple servers 

if we do not care about the CrossOrigin from any website we can do 
@CrossOrigin, and by default this is a wildard that will alow access from any website 

finally we display a list of product onto an html table 
we can create a reference to /assets/images 

assets folder is a special directory you can place your web assets here: images, js, css pdfs and etc. it can also add subdirectories with any names 



## template integration 

we need to search for food by category
search for food by textbox 
and master detail view of food 
we need pagination support of food 
add products to shopping cart using CRUD
and shopping cart checkout 

fontawesome is just a group of glyph icons 



we will install bootstrap css locally using npm 

```shell
C:\Users\Eddie\Desktop\food\frontend\food-app>npm install bootstrap

added 2 packages, removed 1 package, and audited 895 packages in 5s

95 packages are looking for funding
  run `npm fund` for details

6 vulnerabilities (3 low, 3 moderate)

To address all issues, run:
  npm audit fix --force

Run `npm audit` for details.

C:\Users\Eddie\Desktop\food\frontend\food-app>npm audi fix
C:\Users\Eddie\Desktop\food\frontend\food-app>npm audi fix --force
npm WARN using --force Recommended protections disabled.
npm WARN audit Updating @angular-devkit/build-angular to 13.2.2,which is outside your stated dependency range.

added 19 packages, removed 18 packages, changed 34 packages, and audited 896 packages in 21s

95 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

C:\Users\Eddie\Desktop\food\frontend\food-app>npm install @fortawesome/fontawesome-free

added 1 package, and audited 897 packages in 7s

95 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

C:\Users\Eddie\Desktop\food\frontend\food-app>

```
many change in newer versions , it is a moving issue 

verify entries in node_modules directory 
validate the package in package.json 

add to angular.json, this style will be globally applied there is no need to manually reference in your angular components, these styles are available globally 

```json
       "styles": [
              "src/styles.css",
              "node_modules/bootstrap/dist/css/bootstrap.min.css"
           
            ],

```

let's replacethe favicon.ico , you need either clear the cache or you can do a little url trick to froce the browser to get a new version 
to avoid caching issue give unique query params 


```html
  <link rel="icon" type="image/x-icon" href="favicon.ico?v=2">

```
just swing over to the terminal and see how our integeration work 
just for the sanity sake 

we will make a small change on the base url to define the size 

```
http://localhost:8012/food?size=100

```

should we store images as blob? in general imagse stored in the databse is slower than imags stored on the file system. it really deppends on our app requirements 



# angular routing
in angular , you can add links in your app.
the links will route to other component 
angular app will handle updating a view in your app 

it only updates a view of your page -- partial and it does not update your whole page 



### Router: main routing service. enables navigation between views based on user actions 
### Route maps a URL path to a component 
### RouterOutlet acts as a placeholder, renders the desired component based on route 
### RouterLink: link to specific routes in our app 
### ActivatedRoute: the curent active route that loaded the component, useful for accessing route  parameter 


a route has a path and a reference to a component 
when the user selects the link for the route path
angular will create a new instance of component 
one thing to notice is that the path has no leading slashes 
route can have id the component can read this later and show it for this catgory 
we can also add routes to handle for other cases 
```TS
const routes : Routes = [
  {path : 'xxxx', component: xxxComponent},
  {path : 'xxx/:id', component: xxxComponent},
  {path: '', redirectTo: '/xxxx', pathMatch:'full' },
    {path: '**', redirectTo: '/xxxx', pathMatch:'full' },
]

```
no path given , redirect to :/xx this is an exception to the rule about no leading slashes 
full maens match exactly the same. default option will match prefix path starts with a given value 

the generic ** wildcard will match anything that did not match the above routes, it is like an else case 

we can also add a custom PageNotFoundComponent 404 instead you give something did not match instead of redirecting to the main page , you can give it any name for custom component that you create for custom view 

be sure to place this last, order of routes is important, first match wins. starts from most specifci to most generic 


we needto configure the routers in the app module 

```TS
const routes: Routes = [];


@ngModule({

  imports: [
    RouterModule.forRoot(routes),
  ]
})

```


```TS
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { FoodListComponent } from './components/food-list/food-list.component';
import { FoodService } from './services/food.service';
import { HttpClientModule } from '@angular/common/http';
import { NavbarComponent } from './components/navbar/navbar.component';
import { FooterComponent } from './components/footer/footer.component';
import { DetailComponent } from './detail/detail.component';
import { from } from 'rxjs';

import {Routes, RouterModule} from '@angular/router';

const routes: Routes = [
  // PATH TO MATCH and when path matches create new instance of the component 

{path: 'category/:id', component: FoodListComponent},
{path: 'category', component: FoodListComponent},
{path: '', redirectTo:'/food', pathMatch:"full"},
// this is one exception 
{path:'**', redirectTo:'/food',pathMatch:'full'}
// this is a generic wildcard will match on anything that did not match above routes 
];
// the order of routes are important 

@NgModule({
  declarations: [
    AppComponent,
    FoodListComponent,
    NavbarComponent,
    FooterComponent,
    DetailComponent
 
  ],
  imports: [
    RouterModule.forRoot(routes),
    BrowserModule,
    HttpClientModule
  ],
  providers: [FoodService],
  bootstrap: [AppComponent]
})
export class AppModule { }


```

Router Outlet acts as a plae holder, it renders the desried component based on route 


```html
<router-outlet> </router-outlet>


```

in the app.component.html 
location we define the router outlet for app-list-app 

```ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import {map} from 'rxjs/operators';
import { Food } from '../common/food';
import { Inject } from '@angular/core';


@Injectable({
  providedIn: 'root'
})

export class FoodService {

  private baseUrl = "http://localhost:8012/food?size=100";

  // behind the scene is the injectable 
  constructor(private  httpClient : HttpClient ) { }


 // this returns an obsevable map the json data from spring data REST to foood array 
  getFoodList(categoryId: number): Observable<Food[]>{
  
    

        return this.httpClient.get<GetResponse>(this.baseUrl).pipe(
          map(response => response._embedded.food)
        );


  }
}

// adding supporting interface at the bottom 
// this helps us to unwrap the json from spring data REST _embedded entry 
interface GetResponse{
  _embedded:{
    food: Food[];
  }
}


```



remember only updates a sectin of your page does not reload the entire page 

we simply perform partial updates on our given page 


we need to update our app.component.html to use router outlet 
so based on the router configuration it shows at this given location 
it creates an instance of the componeent and display products based on the id 

we nned to comment out or delete the reference to app-xxx-list, we no longer need this directly 


this information will be updated dynamically based on the actual router set up 

we pass category id as a parameter 


once user clicks on this link, then we can apply a custom css style which is totally optinoal 



we will make this dynamic and read category info from test api , i got you covered 

```html
<a routerLink="/category/1">
</a>
```
when user clicks the link, the product list will appear in the location of router-outlet and it does not reload entire page 


we enhance the ListComponent to read category id param 

```
currentCategoryId:number;
this.currentCategoryId = + this.route.snapshot.paramMap.get('id')

```
route use the actived route
snapshot is th state of route at this given moment in time 
paraMap is the map of all the route parameters 
id is to read the id parameter 


parameter value is returned as string use the + symbol convert to number 



currently the sprng boot app returns product regardless of category 

we need to modify to only return products for a given category id 
spring data REST and spring data JPA supports query metods 
spring will construct a query based on method naming conventions behind the scenes 

method starting with findBy,readBy, queryBy 

let's break this out a little bit 

```java
public interface XXXRepository extends JpaRepository<T, Long>{
  Page<T> findByXXXId(@RequestParam("id") Long id, Pageable pageable);
}


```

http://localhost:8012/food/search/findByCategoryId?id=418

findByxxx is our query method xxId is matched by id 


use this parameter value, 
so behind the scenes, spring will execute a query similar to this 
SELECT * From xx where xxx_id = ?;

this is magic here, spring is actually creating and executing a query 



## more on query methods 
you can provide your own custom query using @ Query annotation 


```java
@Query("SELECT XX FROM XX WHERE lower(xxx.name) LIKE LOWER(CONCAT('%',:SEARCHtEEXT, "%"))")
Page <T> doCustomStuff(@RequestParam("xxx") String text, Pageable pageable);

```
support is avaialble for conditions: and , or , like sort and etc 
for details on this topic, see the query method section in the spring data reference manual 


Page and Pageable provides support for pagination 
page is a sublist of a list of objects, has info such as totalElement, totalPages, currentPosition etc 
Pageable represents pagination info has info such as pageNumber, pageSize, previous, next and etc 

these are craeted automatically for you behind the scene by the spring framework 

spring data REST automatically expose endpoints for query methods 
expose endpoint: /search/<<queryMethod>>

localhost:8080/api/xx/search/findByCategoryId

finally we need to update the angular service to call url on spring boot app 


1. now we need to modify the spring boto app to expoes entity ids 
2. create a class FoodCategory 
3. creat new component for menu 
4. enhance menu component to read data from food service 


create a class : xxxCategory 
ng generate class common/food-category 

```TS
export class XXCategory{
  id:number;
  categoryName: string;
}
```



we will encapsulate it in he menu component 



we enhance component to read category by defining our proeprty, inject the service, invoke the method, and log data returned from servevice, finally we assign data to our property 

to update  the service we need to update the url for product, call the api, returns an observable map the json data from spring data to the array. we unwrap the data 

finally we need to make dynamic routers and make a selector for this , it is all power from the backedn database 




now we need to use angular code 

```shell
ng generate class common/category 

```

this creates a category for us 


```TS
export class Category{
  id:number;
  categoryName: string;
}

```



let's create a new component for our menu 

```shell
ng generate component components/category-menu

```


in menu.ts 


```ts
  getCategories() : Observable<Category[]>{
    return this.httpClient.get<GetResponseCategory>().pipe(map(response => response._embedded.category));
    
  }
```
```ts
  getCategories() : Observable<Category[]>{
    return this.httpClient.get<GetResponseCategory>(this.categoryUrl).pipe(map(response => response._embedded.category));
    
  }

```


we are in good shape here 


1. modify spring boot app -- add new search method 
2. create new component for search 
3. add new angular route for search 
4. updte search component to send data to search route 
5. enhance the List component to search for products with service 
6. update the service to call url on spring boot app 

```shell
ng generate component components/search
```
we needto add that operation and perform the search on it 

## event bionding 
in angular, we can listen for events with event binding 
in other lanugages or frameworks, also known as event handling 

```html
<button = (click) = "doSomething1()"> xxx</button>

<input #myInput type = "text" (keyup.enter)="doSomething2(myInput.value)">
```

```TS
exportr class xxx implements OnInit{
  doSomething(){

  }
  dosSomething2(info: string){

  }
}

```

when user typed in so then we can pass that onto our custom method as a string 



### other events 
- focus. an element has received focus 
- blur. an element has lost focus 
- key up, any key is release for a speci the enter use keyup.enter 
- keydown, any key is pressed 
- dblclick, the mouse is clicked twice on an element 


1. user enter search text 
2. click search button
3. search component has a click handler method 

4. read search text 
5. route search data to the search route 
6. handle by the list component 

we want to reuse the component that we already have that functionality in place 


update search component to send data 


```html

<div>
<input #myInput type = "text" placeholder = "xxx" (keyup.enter)="function(myInput.value)">
 <button (click)="function(myInput.value)">
 search
 </button>
 </div>

```

event fired when user clicks the mouse button
event fired when user hit the enter key 


methods defined in our component we can give it any name 
```TS

export class xxxComponent implements OnInit{
  constructor(private router: Router){}
  xxx(value:string){
    this.router.navigateByUrl(`/search/${value}`);
  }
}


```



route the data to our search route it will be handled by the List compoennt 
to reuse the logic and view for listing products 

enhane the component to search for product 


```ts

const keyword: string = this.route.snapshot.paramMap.get('keyword');

this.xxService.searchProducts(keyword).subscribe( data => {this.product=data;})

```

pass in from search component 


search service.ts 

```ts
searchProducts(keyword:string) Observable<Product[]>{
  const searchUrl = `${this.baseUrl}/search/findByNameContaining?name=${kkeyword}`;
return this.httpClient.get<GetResponseXXinterface>(searchUrl).pipe(map(response => response._embeded.products));
}


interface GetResponseXXinterface{
  _embedded:{
    models: Model[];
  }
}

```

this returns an observable map the json data from sprng data rest tro product array 
it unwraps the json from sprng data rest _embedded entry 

add route to app.module.ts 

```ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { FoodListComponent } from './components/food-list/food-list.component';
import { FoodService } from './services/food.service';
import { HttpClientModule } from '@angular/common/http';
import { NavbarComponent } from './components/navbar/navbar.component';
import { FooterComponent } from './components/footer/footer.component';
import { DetailComponent } from './detail/detail.component';
import { from } from 'rxjs';

import {Routes, RouterModule} from '@angular/router';
import { CategoryMenuComponent } from './components/category-menu/category-menu.component';

const routes: Routes = [
  // PATH TO MATCH and when path matches create new instance of the component 
{path: 'search/:keyword', component: FoodListComponent }
{path: 'category/:id', component: FoodListComponent},
{path: 'category', component: FoodListComponent},
{path: '', redirectTo:'/category', pathMatch:"full"},
// this is one exception 
{path:'**', redirectTo:'/category',pathMatch:'full'}
// this is a generic wildcard will match on anything that did not match above routes 
];
// the order of routes are important 

@NgModule({
  declarations: [
    AppComponent,
    FoodListComponent,
    NavbarComponent,
    FooterComponent,
    DetailComponent,
    CategoryMenuComponent
 
  ],
  imports: [
    RouterModule.forRoot(routes),
    BrowserModule,
    HttpClientModule
  ],
  providers: [FoodService],
  bootstrap: [AppComponent]
})
export class AppModule { }

```


ng generate component components/search
CREATE src/app/components/search/search.component.html (21 bytes)
CREATE src/app/components/search/search.component.spec.ts (626 bytes)
CREATE src/app/components/search/search.component.ts (275 bytes)
CREATE src/app/components/search/search.component.css (0 bytes)
UPDATE src/app/app.module.ts (1688 bytes)


then update the search component to search to the data route 
```TS
import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';

@Component({
  selector: 'app-search',
  templateUrl: './search.component.html',
  styleUrls: ['./search.component.css']
})
export class SearchComponent implements OnInit {
  keyWord: string;

  constructor(private router:Router) { }

  ngOnInit(): void {
  }

  search(value:string){
    console.log(`value=${value}`);
    this.router.navigateByUrl(`/search/${value}`);
    // this calls the path:'search/:keyword', component = "foodListComponent"
  // it route the dat to our search route will be handled by the component 

  
  }

}


```


add a display page with ? safe guard navigation opertor ? 
it guards against null and undefined value in property paths 



```ts

                <div *ngIf = "foods?.length == 0" class = "jumbotron jumbotron-fluid">
                  <div class="container">
                   <h1> Speciality </h1>
                    <p class="lead">enter desired food by correct category or keyword</p>
                  </div>
                  </div>
 
         
          

```



master view, user clicks the product to see the details 
detail view. application shows the details for selected products 

1. create new component for product details 
ng generate component components/xxxDetails
2. add new angular route for product details
```
{path: 'xxx/:id', component: xxxDetailsComponent} 
```
3. add router links to the product list html page 
4. enhance the component to retrive product from product service 
```ts 
const productId : number = +this.route.snapshot.paramMap.get('id');

this.xxxService.getProuct(productId).subscribe(data => {this.product =data});


```
get product is a new method, it retrives product from xxService


```ts
getProduct(id:number): Observable<T>{
  const url = `${this.url}/${id}`;
  return this.httpClient.get<T>(url);
}

```
call REST API and it returns an observable JSON data return can be converted directly to object 
no need to unwrap the json from spring data REST and there is no _embedded entry 

built-in feature of spring data REST no additional coding or config required 
this json can be converted directly to product object json properties map directly to properties in the product class 



5. update service to call url on spring boot app 

```ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { FoodListComponent } from './components/food-list/food-list.component';
import { FoodService } from './services/food.service';
import { HttpClientModule } from '@angular/common/http';
import { NavbarComponent } from './components/navbar/navbar.component';
import { FooterComponent } from './components/footer/footer.component';
import { from } from 'rxjs';

import {Routes, RouterModule} from '@angular/router';
import { CategoryMenuComponent } from './components/category-menu/category-menu.component';
import { SearchComponent } from './components/search/search.component';

import { DetailComponent } from './components/detail/detail.component';

const routes: Routes = [
  // PATH TO MATCH and when path matches create new instance of the component 
  {path:'food/:id', component: DetailComponent},
  {path: 'search/:keyword', component: FoodListComponent },
{path: 'category/:id', component: FoodListComponent},
{path: 'category', component: FoodListComponent},
{path: '', redirectTo:'', pathMatch:"full", component: FoodListComponent},
// this is one exception 
{path:'**', redirectTo:'',pathMatch:'full', component: FoodListComponent},
// this is a generic wildcard will match on anything that did not match above routes 

];
// the order of routes are important 

@NgModule({
  declarations: [
    AppComponent,
    FoodListComponent,
    NavbarComponent,
    FooterComponent,
    DetailComponent,
    CategoryMenuComponent,
    SearchComponent
 
  ],
  imports: [
    RouterModule.forRoot(routes),
    BrowserModule,
    HttpClientModule
  ],
  providers: [FoodService],
  bootstrap: [AppComponent]
})
export class AppModule { }


```

let's wing to our ide and loop over the through the actual product 

```html

           
                <div class=" col-md-6 col-lg-4" *ngFor = "let food of foods">
                    <div class="card">
                        <img class="card-img-top shadow-none p-3 mb-5 bg-light rounded" src="https://dummyimage.com/600x400/55595c/fff" alt="Card image cap">
                        <div class="card-body">
                            <h4 class="card-title"><a routerLink="/food/{{food.id}}" title="View Product">{{food.foodName}}</a></h4>
                            <p class="card-text">{{food.foodDescription}}</p>
                            <div class="row">
                                <div class="col">
                                    <p>{{food.price}} $</p>
                                </div>
                                <div class="col">
                                    <p>      {{food.stock}} in stock</p>
                                </div>
                                <div class="col">
                                    <a href="#" class="btn btn-success btn-block">Add to cart</a>
                                </div>
                            </div>
                        </div>
                    </div>
```



```ts
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Food } from 'src/app/common/food';
import { FoodService } from 'src/app/services/food.service';

@Component({
  selector: 'app-detail',
  templateUrl: './detail.component.html',
  styleUrls: ['./detail.component.css']
})
export class DetailComponent implements OnInit {

  food : Food;
  constructor(private foodService: FoodService, private route: ActivatedRoute) { }

  ngOnInit(): void {
    this.route.params.subscribe(() => {
      this.handleFoodDetails();
    });

  }
  handleFoodDetails(){
    // get id a param string, convert string to a number using + symbol 
    const id: number = +this.route.snapshot.paramMap.get('id');
    this.foodService.getFood(id).subscribe(
      data => {
        this.food = data;
      }
    )
  }

}

```


there is a race condition 
why does it work in the browser? 
behind the scnes 
- when the property is assignedthe data finally gets arrived 
- then angular automatically pdates html template 
this is known as data bnding 
this happens behind the scenes 

```ts


@Component({
  selector: 'app-detail',
  templateUrl: './detail.component.html',
  styleUrls: ['./detail.component.css']
})
export class DetailComponent implements OnInit {

  food : Food = new Food();
  constructor(private foodService: FoodService, private route: ActivatedRoute) { }

```


one solution is to assign a new instance to it 

another soltiion is to use safe navigation operator 

?? 
```html
{{food?.foodName}}

```

angular and javascript are very lenient, even though we areusing typescript 
some bugs can still slip through 

we also reference the product to the detail view 
the angular team also provides the angular language service which provides additional support for compilation error, code completion and etc 

install the extension in visual studio code 
menu option : view > extension, search for angular language service and click install 







we will install ng-bootstrap 
refactor the interface for GetResponseFood
add pagination support to FoodService 
update ListComponent to handle pagination 
enhance HTML template to use ng-bootstrap pagination component 

npm install @ng-bootstrap/ng-bootstrap 



```TS
import {NgModule} from '@ng-bootstrap/ng-bootstrap';

@NgModule({
  imports:[]
})

```


refactor the interface for GetReponsefOOD
```TS
interface GetResponseFood{
  _embedded:{
    food: Food[];
  },
  page:{
    size: number,
    totalElements: number,
    totalPages : number,
    number: number
  }
}

```

spring data REST - response meta data 
the response meta data also has valuable info for pagination 

add pagintion support to Service 
```ts

getFoodListPaginte(thePage: number, thePageSize: number, theCategoryId : number) : Observable<GetResponseFood>)
const url = `${this.baseUrl}/search/findByCategoryId` + `?id=${id}&page=${thePage}&size=${thePageSize}`;
return this.httpClient.get<GetResponsFood>(url);


```

update foodlist component to handle pagination 
```ts 

handleListFood(){
  this.foodService.getFoodListPaginate(this.thePageNumber = 1, this.thePageSize, this.currentId).subscribe(this.processResult());
}


private ProcessResult(){
  return data => {
    this.products = data._embeded.food;
    this.thePageNumber = data.page.number + 1;
    this.thePageSize = data.page.size;
    this.theTotalElements = data.page.totalElements;
  }
}



```

when data arrives from the service the nset properties based on the data, everything on the right hand side of assignment is data from spring data REST JSON 


the page number to access 1-based default to 1 
pageSize the size of the page items per page, default to 10

```html
<ngb-pagination [(page)]="thePageNumber"
[(pageSize)]="thePageSize"
[collectionSize]="theTotalElements"
(pageChange)="listFood()">
</ngb-pagination>
```

```
C:\Users\Eddie\Desktop\food\frontend\food-app>ng add @angular/localize
i Using package manager: npm
√ Found compatible package version: @angular/localize@13.1.3.
√ Package information loaded.

The package @angular/localize@13.1.3 will be installed and executed.
Would you like to proceed? Yes
√ Package successfully installed.
UPDATE src/polyfills.ts (2567 bytes)

C:\Users\Eddie\Desktop\food\frontend\food-app>npm install @ng-bootstrap/ng-bootstrap

```

special angular syntax for two way data binding known as banana in a box 
when users clicks then the page number set to a new number 

in our ts component, the page number property is updated based on user action 

if our tes code upates the page number then ui component is updated automatically, current page number is highlighted 

special angular syntax for one way data binding 
parameter of ngb-pagination component and property of list component 

[] is one way data binding, our ts code update the total elements then ui component is updated automatically 

the page change when user clicks a page navigation link then call the method 


we need to access REST API end point and seeing those pagination repose metadata in action
http://localhost:8012/food?page=0&size=2



  "page" : {
    "size" : 2,
    "totalElements" : 6,
    "totalPages" : 3,
    "number" : 0
  }




```TS

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { FoodListComponent } from './components/food-list/food-list.component';
import { FoodService } from './services/food.service';
import { HttpClientModule } from '@angular/common/http';
import { NavbarComponent } from './components/navbar/navbar.component';
import { FooterComponent } from './components/footer/footer.component';
import { from } from 'rxjs';

import {Routes, RouterModule} from '@angular/router';
import { CategoryMenuComponent } from './components/category-menu/category-menu.component';
import { SearchComponent } from './components/search/search.component';

import { DetailComponent } from './components/detail/detail.component';

import { NgbModule } from '@ng-bootstrap/ng-bootstrap';


const routes: Routes = [
  // PATH TO MATCH and when path matches create new instance of the component 
  {path:'food/:id', component: DetailComponent},
  {path: 'search/:keyword', component: FoodListComponent },
{path: 'category/:id', component: FoodListComponent},
{path: 'category', component: FoodListComponent},
{path: '', redirectTo:'', pathMatch:"full", component: FoodListComponent},
// this is one exception 
{path:'**', redirectTo:'',pathMatch:'full', component: FoodListComponent},
// this is a generic wildcard will match on anything that did not match above routes 

];
// the order of routes are important 

@NgModule({
  declarations: [
    AppComponent,
    FoodListComponent,
    NavbarComponent,
    FooterComponent,
    DetailComponent,
    CategoryMenuComponent,
    SearchComponent
 
  ],
  imports: [
    RouterModule.forRoot(routes),
    BrowserModule,
    HttpClientModule,
    NgbModule
  ],
  providers: [FoodService],
  bootstrap: [AppComponent]
})
export class AppModule { }

```


```ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import {map} from 'rxjs/operators';
import { Food } from '../common/food';
import { Inject } from '@angular/core';
import { Category } from '../common/category';


@Injectable({
  providedIn: 'root'
})

export class FoodService {

  private baseUrl = "http://localhost:8012/food";
  private categoryUrl = `http://localhost:8012/category`;

  // behind the scene is the injectable 
  constructor(private  httpClient : HttpClient ) { }


 // this returns an obsevable map the json data from spring data REST to foood array 
  getFoodList(categoryId: number): Observable<Food[]>{

    const searchURL = `${this.baseUrl}/search/findByCategoryId?id=${categoryId}`;
  
    console.log("the search url is " + searchURL);

        return this.httpClient.get<GetResponseFood>(searchURL).pipe(
          map(response => response._embedded.food)
        );


  }

  getFoodListPaginate(thePage: number, thePageSize: number ,categoryId: number) : Observable<GetResponseFood>{
    // need to build url based id, page and size
    const searchUrl = `${this.baseUrl}/search/findByCategoryId?id=${categoryId}`
    + `&page=${thePage}&size=${thePageSize}`;
    // spring data REST supports pagination out of the box, just send the parameters for page and size
    return this.httpClient.get<GetResponseFood>(searchUrl);
  }

  getCategories() : Observable<Category[]>{
    return this.httpClient.get<GetResponseCategory>(this.categoryUrl).pipe(map(response => response._embedded.category));
    
  }

  searchFood(keyword:string): Observable<Food[]>{
    const searchURL = `${this.baseUrl}/search/findByfoodNameContaining?name=${keyword}`;

    return this.httpClient.get<GetResponseFood>(searchURL).pipe(map(response => response._embedded.food));
  } 

  getFood(foodId:number): Observable<Food>{
    // need to build url based on the food id

    const foodUrl = `${this.baseUrl}/${foodId}`;
    return this.httpClient.get<Food>(foodUrl);
    // we do not need response => response._embedded 

  }





}

// adding supporting interface at the bottom 
// this helps us to unwrap the json from spring data REST _embedded entry 
interface GetResponseFood{
  _embedded:{
    food: Food[];
  },
  page: {
    size: number, // size of the page 
    totalElements: number; // grand total number of all elements in the datbase, but we are not returning all of the elemtns, just count for informational purposes only 
    totalPages : number, //  total pages available 
    number : number // current page number 
  }
}

interface GetResponseCategory{
  _embedded:{
    category: Category[];
  }
}




 

```



```html


 
 
 
    <div class="row">
     
    <app-category-menu>

    
    </app-category-menu> 
   

     
            <div class="row content">

           
                <div class=" col-md-6 col-lg-4" *ngFor = "let food of foods">
                    <div class="card">
                        <img class="card-img-top shadow-none p-3 mb-5 bg-light rounded" src="https://dummyimage.com/600x400/55595c/fff" alt="Card image cap">
                        <div class="card-body">
                            <h4 class="card-title"><a routerLink="/food/{{food.id}}" title="View Product">{{food.foodName}}</a></h4>
                            <p class="card-text">{{food.foodDescription}}</p>
                            <div class="row">
                                <div class="col">
                                    <p>{{food.price}} $</p>
                                </div>
                                <div class="col">
                                    <p>      {{food.stock}} in stock</p>
                                </div>
                             
                            </div>
                        </div>
                    </div>
                    
                </div>
          
                <div *ngIf = "foods?.length == 0" class = "jumbotron jumbotron-fluid">
                  <div class="container">
                   <h1> Speciality </h1>
                    <p class="lead">search your food by category or keyword</p>
                  </div>
                  </div>
 
         
          

    <div>




        <!--pagination-->

        <ngb-pagination
        [(page)]="thePageNumber"
        [pageSize]="thePageSize"
        [collectionSize]="theTotalElements"
        (pageChange)="listFood()"
        >
          </ngb-pagination>
  
       
            <!-- <nav class = "content">
                <ul class="pagination">
                    <li class="page-item disabled">
                        <a class="page-link" href="#" tabindex="-1">Previous</a>
                    </li>
                    <li class="page-item"><a class="page-link" href="#">1</a></li>
                    <li class="page-item active">
                        <a class="page-link" href="#">2 </a>
                    </li>
                    <li class="page-item"><a class="page-link" href="#">3</a></li>
                    <li class="page-item">
                        <a class="page-link" href="#">Next</a>
                    </li>
                </ul>
            </nav> -->
        </div>
    </div>
 
        </div>
        <!--pagination-->
```


```ts
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Food } from 'src/app/common/food';
import { FoodService } from 'src/app/services/food.service';

@Component({
  selector: 'app-food-list',
  templateUrl: './food-list.component.html',
  styleUrls: ['./food-list.component.css']
})
export class FoodListComponent implements OnInit {


  // a bit house keeping 
  foods : Food[] = [];
  currentCategoryId : number = 1;
  previousCategoryId : number = 1;
  searchMode : boolean = false;


  // new propery for pagination 
  thePageNumber : number = 1;
  thePageSize: number = 3;
  theTotalElements : number = 0;


  constructor(private foodService : FoodService, private route : ActivatedRoute) { }

  // similar to @PostContruct in spring 
  ngOnInit(): void {
    this.route.paramMap.subscribe(() => {
      this.listFood();

    });
  }

  listFood(){
    this.searchMode = this.route.snapshot.paramMap.has("keyword");
    // keyword comes from {path:"search:keyword", component: Food}
    // this.router.navigateByUrl(`/search/${value}`)
    if(this.searchMode){
      this.handleSearchFood();
    }else{
      
    this.handleListFood();
    // keep the flow going 

    }


  }

  handleSearchFood(){
    const keyword: string = this.route.snapshot.paramMap.get("keyword")!;
    // now search for food 
    this.foodService.searchFood(keyword).subscribe(
      data => {
        this.foods = data;
      }
    )

  }

  handleListFood(){
    // check if id parameter is avaialbel 
    const hasCategoryId: boolean = this.route.snapshot.paramMap.has("id");

    if(hasCategoryId){
      //get the id para string, convert string to a number using + 
      this.currentCategoryId = +this.route.snapshot.paramMap.get('id')!;
 
    }else{
      // no available category id
     
      this.currentCategoryId = 1;
    }

    // check if we have a different than previous 
    // note: angular will reuse a component if it is currently being view 
    // if we have a different category id than previous than set the page number back to 1 

    if(this.previousCategoryId != this.currentCategoryId){
       this.thePageNumber = 1;
    }
    this.previousCategoryId = this.currentCategoryId;
    console.log(`currentCategoryId=${this.currentCategoryId}, thePageNumber=${this.thePageNumber}`);


    // swing to service now get the products for the given category id 
    this.foodService.getFoodListPaginate(this.thePageNumber - 1, this.thePageSize, this.currentCategoryId).subscribe(this.processResult());
    
  }

  processResult(){
    return (data: { _embedded: { food: Food[]; }; page: { number: number; size: number; totalElements: number; }; })  => {
      this.foods = data._embedded.food;
      this.thePageNumber = data.page.number + 1;
      // spring data rest pages are 0 based code should resemble what we have here 
      this.thePageSize = data.page.size;
      this.theTotalElements = data.page.totalElements;
      // left hand side of assignment are properties defined in this class 

    } ;
  }


}


```


we need to let the user to select the size of pagination 
1. add dropdwon list for page size to html tempalte 
2. update list component for page size 



```html
<select (change)= updatePageSize($event>
<option selected="true">3 </option>
<option>10</option>
<option>20</option>
  </select>

```



```ts
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Food } from 'src/app/common/food';
import { FoodService } from 'src/app/services/food.service';

@Component({
  selector: 'app-food-list',
  templateUrl: './food-list.component.html',
  styleUrls: ['./food-list.component.css']
})
export class FoodListComponent implements OnInit {


  // a bit house keeping 
  foods : Food[] = [];
  currentCategoryId : number = 1;
  previousCategoryId : number = 1;
  searchMode : boolean = false;


  // new propery for pagination 
  thePageNumber : number = 1;
  thePageSize: number = 3;
  theTotalElements : number = 0;


  constructor(private foodService : FoodService, private route : ActivatedRoute) { }

  // similar to @PostContruct in spring 
  ngOnInit(): void {
    this.route.paramMap.subscribe(() => {
      this.listFood();

    });
  }

  listFood(){
    this.searchMode = this.route.snapshot.paramMap.has("keyword");
    // keyword comes from {path:"search:keyword", component: Food}
    // this.router.navigateByUrl(`/search/${value}`)
    if(this.searchMode){
      this.handleSearchFood();
    }else{
      
    this.handleListFood();
    // keep the flow going 

    }


  }

  handleSearchFood(){
    const keyword: string = this.route.snapshot.paramMap.get("keyword")!;
    // now search for food 
    this.foodService.searchFood(keyword).subscribe(
      data => {
        this.foods = data;
      }
    )

  }

  handleListFood(){
    // check if id parameter is avaialbel 
    const hasCategoryId: boolean = this.route.snapshot.paramMap.has("id");

    if(hasCategoryId){
      //get the id para string, convert string to a number using + 
      this.currentCategoryId = +this.route.snapshot.paramMap.get('id')!;
 
    }else{
      // no available category id
     
      this.currentCategoryId = 1;
    }

    // check if we have a different than previous 
    // note: angular will reuse a component if it is currently being view 
    // if we have a different category id than previous than set the page number back to 1 

    if(this.previousCategoryId != this.currentCategoryId){
       this.thePageNumber = 1;
    }
    this.previousCategoryId = this.currentCategoryId;
    console.log(`currentCategoryId=${this.currentCategoryId}, thePageNumber=${this.thePageNumber}`);


    // swing to service now get the products for the given category id 
    this.foodService.getFoodListPaginate(this.thePageNumber - 1, this.thePageSize, this.currentCategoryId).subscribe(this.processResult());
    
  }

  processResult(){
    return (data: { _embedded: { food: Food[]; }; page: { number: number; size: number; totalElements: number; }; })  => {
      this.foods = data._embedded.food;
      this.thePageNumber = data.page.number + 1;
      // spring data rest pages are 0 based code should resemble what we have here 
      this.thePageSize = data.page.size;
      this.theTotalElements = data.page.totalElements;
      // left hand side of assignment are properties defined in this class 

    } ;
  }


  updatePageSize(event: Event){
    this.thePageSize = +(event.target as HTMLInputElement).value;
    this.thePageNumber = 1;
    this.listFood();
  }


}


```

you can set  the max size boundry links for pagination 

what if we had 1 million producs??? should only show a max number of pages 

```html

  <ngb-pagination
        [(page)]="thePageNumber"
        [pageSize]="thePageSize"
        [collectionSize]="theTotalElements"
        [maxSize]="5"
        (pageChange)="listFood()"
        >
          </ngb-pagination>
```


the key here is that it is limitng the number of pages 

we can show boundary links << and >> jump to beginning or end page 

```html

        <ngb-pagination
        [(page)]="thePageNumber"
        [pageSize]="thePageSize"
        [collectionSize]="theTotalElements"
        [maxSize]="5"
        (pageChange)="listFood()"
        [boundaryLinks]="true"
        >
          </ngb-pagination>

```


add pagination for keyword search 
1. add pagination support to food service 
2. update list coomponent to handle pagination 

```ts

searchFoodPaginate(thePage:number, thePageSize:number, theKeyword : string): Observable<GetResonpseProducts>{
  const searchUrl = `${this.baseURL}/search/findByNameContaining` + `?name${theyKeyword}&page=${thePage}&size=${thePageSize}`;
  return this.httpClient.get<GetResponseProducts>(searchUrl);
}

```

spring data rest supports pagination out of the box, just send the parameters for page and size 

```ts 
handleSearchFood(){
  const theKeyword: string.route.snapshot.paramMap.get("keyword");


  this.xxService.sarchFoodPaginate(this.thePageNumber = 1, this.thePageSize, theKeyword).subscribe(this.processResult());
}


private processResult() {
  return data =>{
    this.foodt = data._embedded.food;
this.thePageNumber = data.page.number + 1;
this.thePageSize = data.page.size;
this.theTotalElements = data.page.totalElements;
  }
}

```
call service and pass in parameter, pagination component: pages are 1 based, spring data REST pages are 0 based 


```ts

  searchFoodListPaginate(thePage: number, thePageSize: number ,keyword: string) : Observable<GetResponseFood>{
    // need to build url based id, page and size
    const searchUrl = `${this.baseUrl}/search/findByfoodNameContaining?name=${keyword}`
    + `&page=${thePage}&size=${thePageSize}`;
    // spring data REST supports pagination out of the box, just send the parameters for page and size
    return this.httpClient.get<GetResponseFood>(searchUrl);
  }


```


```ts 

  handleSearchFood(){
    const keyword: string = this.route.snapshot.paramMap.get("keyword")!;
    // now search for food 
    

    // if we have a diffrent keyword than previous 
    // then set the page number to 1 

    if(this.previousKeyword != keyword){
      this.thePageNumber = 1;

    }
    this.previousKeyword = keyword;


console.log(`keyword=${keyword}, thepage number = ${this.thePageNumber}`);



   // now search for the produt using keyword 
    this.foodService.searchFoodListPaginate(
      this.thePageNumber - 1,
      this.thePageSize,
      keyword
    ).subscribe(this.processResult());

  }

```


adding product on the shopping cart 


```html

<div class = "total btn btn-outline-secondary">
   <span> <i class = "fa fa-shopping-cart" aria-hidden="true"> </i></span>

    <span>$100.0  </span>
    <span> 12 </span> 


</div>
```


```html

                                            <div class = "col">

                                  <button type="button" class="btn btn-success" (click)="addToCart(food)">Add to Cart</button>

                                </div>
                             
                             
                             

```

```ts

  addToCart(food:Food){
    console.log(`adding to cart ${food.foodName} ${food.price}`);

  }

```

we want to keep track of the status and the total quantity 

we need to create a model class called cartItem 
develop the cartService 
modify FoodListComponent to call CartService 
enhance CartStatusComponent to subscribe to CartService 
updateCartStatusComponent HTML to display cart total price and quantity 

we have the list component to add to cart button 
and also have the cart status component for quantity and price 

and we have cart service that keeps track of all items that are in our cart 

1. we subscribe for events 
2. addToCart
3. publish events to all subscribers 
4. update UI for total price and quantity 

create a model class called CartItem
```ts
export class CartItem{
    id: string;
    name : string;
    imageUrl : string;
    price: number;
    quantity: number;

    constructor(food: Food){
        this.id = food.id;
        this.name = food.foodName;
        this.imageUrl = food.imageUrl;
        this.price = food.price;
        this.quantity = food.quantity;

    }
}

```

it contains essential fields of food for use in this cart
also has a field for quantity 



we develop cart service 
```ts
import { Subject } from "rxjs";
import { CartItem } from "../common/CartItem";

export class CartService{

    cartItem: CartItem[] = [];

    totalPrice : Subject<number> = new Subject<number>();
    totalQuantity: Subject<number> = new Subject<number>();
    
}
```
Subject is a subclass of Observable 
we can use subject to publish events in our code 
and the event will be sent to all of the subscribers 

```ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { FoodListComponent } from './components/food-list/food-list.component';
import { FoodService } from './services/food.service';
import { HttpClientModule } from '@angular/common/http';
import { NavbarComponent } from './components/navbar/navbar.component';
import { FooterComponent } from './components/footer/footer.component';
import { from } from 'rxjs';

import {Routes, RouterModule} from '@angular/router';
import { CategoryMenuComponent } from './components/category-menu/category-menu.component';
import { SearchComponent } from './components/search/search.component';

import { DetailComponent } from './components/detail/detail.component';

import { NgbModule } from '@ng-bootstrap/ng-bootstrap';
import { CartStatusComponent } from './components/cart-status/cart-status.component';
import { CartService } from './services/CartService';


const routes: Routes = [
  // PATH TO MATCH and when path matches create new instance of the component 
  {path:'food/:id', component: DetailComponent},
  {path: 'search/:keyword', component: FoodListComponent },
{path: 'category/:id', component: FoodListComponent},
{path: 'category', component: FoodListComponent},
{path: '', redirectTo:'', pathMatch:"full", component: FoodListComponent},
// this is one exception 
{path:'**', redirectTo:'',pathMatch:'full', component: FoodListComponent},
// this is a generic wildcard will match on anything that did not match above routes 

];
// the order of routes are important 

@NgModule({
  declarations: [
    AppComponent,
    FoodListComponent,
    NavbarComponent,
    FooterComponent,
    DetailComponent,
    CategoryMenuComponent,
    SearchComponent,
    CartStatusComponent
 
  ],
  imports: [
    RouterModule.forRoot(routes),
    BrowserModule,
    HttpClientModule,
    NgbModule
  ],
  providers: [FoodService, CartService],
  bootstrap: [AppComponent]
})
export class AppModule { }


```
```ts
import { Subject } from "rxjs";
import { CartItem } from "../common/CartItem";
 

export class CartService{

    cartItem: CartItem[] = [];

    totalPrice : Subject<number> = new Subject<number>();
    totalQuantity: Subject<number> = new Subject<number>();

    


    
    

    addToCart(theCartItem : CartItem){
        console.log("see this ");

        let existingItemFlag : boolean = false;
        let existingCartItem = undefined;
  
        if(this.cartItem.length > 0){
        for(let item of this.cartItem){
            if (item.id === theCartItem.id){
                existingCartItem = item;
            
                break;
                // if so we assign it and then we break out of the loop

            }
        }
        existingItemFlag = existingCartItem != undefined;
     
     

    }


    if(existingItemFlag){
        existingCartItem!.quantity++;
    }else{
     
        this.cartItem.push(theCartItem);
    }
 
    console.log("this is called before compute totals");

    this.computeTotals();
    }

    computeTotals(){
        let totalPriceValue : number = 0;
        let totalQuantityValue : number = 0;

        console.log("currentItem length:" + this.cartItem.length);
       

        for(let currentCartItem of this.cartItem){
            totalPriceValue += currentCartItem.quantity * currentCartItem.price;
            totalQuantityValue += currentCartItem.quantity;

            console.log(`current item quantity is ${currentCartItem.price}`);
        }

        this.totalPrice.next(totalPriceValue);
        this.totalQuantity.next(totalQuantityValue);

        console.log(`the total price is ${totalPriceValue}`);
        console.log(`the total quantity is ${totalQuantityValue}`);
        // publish the new values all sucbribers will receive the new data and update real time 
        // next method push and send events 
    }
}
```

now update the list component to call service 

```ts 

import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { CartItem } from 'src/app/common/CartItem';
import { Food } from 'src/app/common/food';
import { CartService } from 'src/app/services/CartService';
import { FoodService } from 'src/app/services/food.service';

@Component({
  selector: 'app-food-list',
  templateUrl: './food-list.component.html',
  styleUrls: ['./food-list.component.css']
})
export class FoodListComponent implements OnInit {


  // a bit house keeping 
  foods : Food[] = [];
  currentCategoryId : number = 1;
  previousCategoryId : number = 1;
  searchMode : boolean = false;


  // new propery for pagination 
  thePageNumber : number = 1;
  thePageSize: number = 3;
  theTotalElements : number = 0;


  previousKeyword : string;


  constructor(private foodService : FoodService, private cartService: CartService, private route : ActivatedRoute) { }

  // similar to @PostContruct in spring 
  ngOnInit(): void {
    this.route.paramMap.subscribe(() => {
      this.listFood();

    });
  }

  listFood(){
    this.searchMode = this.route.snapshot.paramMap.has("keyword");
    // keyword comes from {path:"search:keyword", component: Food}
    // this.router.navigateByUrl(`/search/${value}`)
    if(this.searchMode){
      this.handleSearchFood();
    }else{
      
    this.handleListFood();
    // keep the flow going 

    }


  }

  handleSearchFood(){
    const keyword: string = this.route.snapshot.paramMap.get("keyword")!;
    // now search for food 
    

    // if we have a diffrent keyword than previous 
    // then set the page number to 1 

    if(this.previousKeyword != keyword){
      this.thePageNumber = 1;

    }
    this.previousKeyword = keyword;


    console.log(`keyword = ${keyword} , the page number = ${this.thePageNumber}`);





   // now search for the produt using keyword 
    this.foodService.searchFoodPaginate(
      this.thePageNumber -= 1,
      this.thePageSize,
      keyword
    ).subscribe(this.processResult());

  }

  handleListFood(){
    // check if id parameter is avaialbel 
    const hasCategoryId: boolean = this.route.snapshot.paramMap.has("id");

    if(hasCategoryId){
      //get the id para string, convert string to a number using + 
      this.currentCategoryId = +this.route.snapshot.paramMap.get('id')!;
 
    }else{
      // no available category id
     
      this.currentCategoryId = 1;
    }

    // check if we have a different than previous 
    // note: angular will reuse a component if it is currently being view 
    // if we have a different category id than previous than set the page number back to 1 

    if(this.previousCategoryId != this.currentCategoryId){
       this.thePageNumber = 1;
    }
    this.previousCategoryId = this.currentCategoryId;
    console.log(`currentCategoryId=${this.currentCategoryId}, thePageNumber=${this.thePageNumber}`);


    // swing to service now get the products for the given category id 
    this.foodService.getFoodListPaginate(this.thePageNumber - 1, this.thePageSize, this.currentCategoryId).subscribe(this.processResult());
    
  }

  processResult(){
    return (data: { _embedded: { food: Food[]; }; page: { number: number; size: number; totalElements: number; }; })  => {
      this.foods = data._embedded.food;
      this.thePageNumber = data.page.number + 1;
      // spring data rest pages are 0 based code should resemble what we have here 
      this.thePageSize = data.page.size;
      this.theTotalElements = data.page.totalElements;
      // left hand side of assignment are properties defined in this class 

    } ;
  }


  updatePageSize(event: Event){
    this.thePageSize = +(event.target as HTMLInputElement).value;
    this.thePageNumber = 1;
    this.listFood();
  }

  addToCart(food:Food){
    console.log(`adding to cart ${food.foodName} ${food.price}`);
    const theCartItem = new CartItem(food);
    

    this.cartService.addToCart(theCartItem); // it calls cart service 
    

    

  }


}

```


enhance the cart status component to subscribe to the service 



we can refactor the cart service because we are using the basic for loop to loop through the cart items 

# we use Array.find(...)
this method returns the first element in an array that passes a given test 

```ts
result = this.list.find( item => item === condition)

```

executes the test for each element in the array until the test passses 

if test passes, then returns the first element in the array that passed 
if test fails for all elements in the array, then returns undefined 



we need to add handler for add to cart button on the details component 
update th detail component with click handler method 

```ts
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { CartItem } from 'src/app/common/CartItem';
import { Food } from 'src/app/common/food';
import { FoodService } from 'src/app/services/food.service';
import { CartService } from 'src/app/services/CartService';

@Component({
  selector: 'app-detail',
  templateUrl: './detail.component.html',
  styleUrls: ['./detail.component.css']
})
export class DetailComponent implements OnInit {

  food : Food = new Food();
  constructor(private foodService: FoodService, private cartService: CartService, private route: ActivatedRoute) { }

  ngOnInit(): void {
    this.route.params.subscribe(() => {
      this.handleFoodDetails();
    });

  }
  handleFoodDetails(){
    // get id a param string, convert string to a number using + symbol 
    const id: number = +this.route.snapshot.paramMap.get('id')!;
    this.foodService.getFood(id).subscribe(
      data => {
        this.food = data;
      }
    )
  }

  addToCart(food: Food){
    const theCartItem = new CartItem(this.food);
    this.cartService.addToCart(theCartItem);
    
  }

}

```


we want to list the items in our cart 


1. create new component : CartDetailsComponent

ng generate component components/cart-details 

add route to the cart details in app.module.ts file 

2. add new route for CartDetailsComponent

3. update link for shopping cart icon 
```ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { FoodListComponent } from './components/food-list/food-list.component';
import { FoodService } from './services/food.service';
import { HttpClientModule } from '@angular/common/http';
import { NavbarComponent } from './components/navbar/navbar.component';
import { FooterComponent } from './components/footer/footer.component';
import { from } from 'rxjs';

import {Routes, RouterModule} from '@angular/router';
import { CategoryMenuComponent } from './components/category-menu/category-menu.component';
import { SearchComponent } from './components/search/search.component';

import { DetailComponent } from './components/detail/detail.component';

import { NgbModule } from '@ng-bootstrap/ng-bootstrap';
import { CartStatusComponent } from './components/cart-status/cart-status.component';
import { CartService } from './services/CartService';
import { CartDetailsComponent } from './components/cart-details/cart-details.component';


const routes: Routes = [
  // PATH TO MATCH and when path matches create new instance of the component 
  {path:'food/:id', component: DetailComponent},
  {path: 'cart-details', component: CartDetailsComponent},
  {path: 'search/:keyword', component: FoodListComponent },
{path: 'category/:id', component: FoodListComponent},
{path: 'category', component: FoodListComponent},
{path: '', redirectTo:'', pathMatch:"full", component: FoodListComponent},
// this is one exception 
{path:'**', redirectTo:'',pathMatch:'full', component: FoodListComponent},
// this is a generic wildcard will match on anything that did not match above routes 

];
```


we use router link for cart detail html 

```html

<div >

    <a routerLink = "/cart-details" class = "total btn btn-outline-secondary" >
   <span> <i class = "fa fa-shopping-cart" aria-hidden="true"> </i></span>

    <span>${{totalPrice}}  </span>
    <span> {{totalQuantity}} </span> 
</a>

</div>
```



4. modify cart details component to retrieve cart items 
```ts
import { Component, OnInit } from '@angular/core';
import { CartItem } from 'src/app/common/CartItem';
import { CartService } from 'src/app/services/CartService';

@Component({
  selector: 'app-cart-details',
  templateUrl: './cart-details.component.html',
  styleUrls: ['./cart-details.component.css']
})
export class CartDetailsComponent implements OnInit {

  cartItems: CartItem[] = [];
  totalPrice : number = 0;
  totalQuantity : number = 0;

  constructor(private cartService : CartService) { }

  ngOnInit(): void {
    this.listCartDetails();
  }


  listCartDetails(){
    this.cartItems = this.cartService.cartItem;

    this.cartService.totalPrice.subscribe(
      data => this.totalPrice = data
    );

    this.cartService.totalQuantity.subscribe(
      data => this.totalQuantity = data
    );

    this.cartService.computeTotals();
  }

}

```


5. add html tempalte for cart detail component
```html

<p>cart-details works!</p>
<table class="table table-striped">
    <thead>
      <tr>
        <th scope="col">#</th>
        <th scope="col">Product Detail</th>
        <th scope="col">Subtotals</th>
    
      </tr>
    </thead>
    <tbody>
      <tr *ngFor="let item of cartItems">
    
        <td>Mark</td>
        <td>
     <p>{{item.name}} </p>
     <p> $ {{item.price }}</p>

        </td>
        <td>
           <label> Quantity:</label> {{item.quantity}}
            <p> Subtotal:$ {{item.quantity * item.price}} </p>
        </td>
      </tr>

      <tr>
     <td colspan="2"> </td>
     <td>
   <p> Total Quantity : {{totalQuantity}}</p>
   <p> Total Price: {{totalPrice}} </p>
    
        </td>

        </tr>
    
    </tbody>
  </table>
```



what about an empty cart???
you aer poking account , 
we can modify the logo and lingering a little bit 



```html

 

 <div *ngIf = "cartItems.length > 0">
<table class="table table-striped">
    <thead>
      <tr>
        <th scope="col">#</th>
        <th scope="col">Product Detail</th>
        <th scope="col">Subtotals</th>
    
      </tr>
    </thead>
    <tbody>
      <tr *ngFor="let item of cartItems">
    
        <td><img width="300" height="200" src="https://dummyimage.com/600x400/55595c/fff"></td>
        <td>
     <p>{{item.name}} </p>
     <p> $ {{item.price }}</p>

        </td>
        <td>
           <label> Quantity:</label> {{item.quantity}}
            <p> Subtotal:$ {{item.quantity * item.price}} </p>
        </td>
      </tr>

      <tr>
     <td colspan="2"> </td>
     <td>
   <p> Total Quantity : {{totalQuantity}}</p>
   <p> Total Price: {{totalPrice}} </p>
    
        </td>

        </tr>
    
    </tbody>
  </table>
  </div>

  <div *ngIf="cartItems.length == 0">

    <div class="jumbotron">
  
    
    <div class="alert alert-info">

    
      please select the food you desire to order

      </div>

      <a class = "btn btn-outline-primary btn-lg" routerLink="/category"> Order Food</a>
    </div>
```


we will focus on increment the quantity 




increment cart 

1. mopidfy cart detail component html template 
add increment button
add click handler for the increment button on html 

```html

        <td>
            <button (click)="incrementQuantity(item)" class = "btn btn-primary"><i class = "fa fa-plus"></i> </button>
     
                {{item.quantity}}
            <button (click)="decrementQuantity(item)" class = "btn btn-primary"><i class = "fa fa-minus"></i> </button>
       </td>

```
```ts
  incrementQuantity(cartItem: CartItem){
    this.cartService.addToCart(cartItem);
  }


```
2. update cart detail component with click handler method 

```ts
import { Component, OnInit } from '@angular/core';
import { CartItem } from 'src/app/common/CartItem';
import { CartService } from 'src/app/services/CartService';

@Component({
  selector: 'app-cart-details',
  templateUrl: './cart-details.component.html',
  styleUrls: ['./cart-details.component.css']
})
export class CartDetailsComponent implements OnInit {

  cartItems: CartItem[] = [];
  totalPrice : number = 0;
  totalQuantity : number = 0;

  constructor(private cartService : CartService) { }

  ngOnInit(): void {
    this.listCartDetails();
  }


  listCartDetails(){
    this.cartItems = this.cartService.cartItem;

    this.cartService.totalPrice.subscribe(
      data => {this.totalPrice = data; this.totalPrice = +this.totalPrice.toFixed(2);}
    );

    this.cartService.totalQuantity.subscribe(
      data => this.totalQuantity = data

    );

    this.cartService.computeTotals();
  }

  incrementQuantity(cartItem: CartItem){
    this.cartService.addToCart(cartItem);
  }

  decrementQuantity(cartItem: CartItem){
    if(cartItem.quantity > 0){
    cartItem.quantity--;
    } 

    if(cartItem.quantity === 0){
      this.remove(cartItem);
    }else{
      this.cartService.computeTotals();

    }
  }

  remove(cartItem: CartItem){

    const index = this.cartItems.findIndex(item => item.id == cartItem.id);
    if(index > -1){
      this.cartItems.splice(index,1);
      this.cartService.computeTotals();
    }

  }

}


```


add remove button


```html

        <td>
            <button (click)="incrementQuantity(item)" class = "btn btn-primary"><i class = "fa fa-plus"></i> </button>
     
                {{item.quantity}}
            <button (click)="decrementQuantity(item)" class = "btn btn-primary"><i class = "fa fa-minus"></i> </button>
      
            <button (click)="remove(item)" class = "btn btn-danger">remove</button>
        </td>
      </tr>

```



## angular forms 
can easily build forms in angular 
support form data binding, validation and processing 
angular provides two types of forms 
reative forms and tempalte driven forms 


the reactive forms: 
leverage programmatic api for form building 
scaleable solution that is designed for large and complex forms 
forms can be easily reused and tested 

template driven forms 
targeted for small simple forms 
they are not a scalable solution for large and complex forms 


we will go for reactive forms 



key components 

FormControl: individual control that tracks the value and validation 
FormGroup : a collection of controls, can create nested groups 
others: ..... details 



for checkout forms we will focus on form constructions and layouts 

we will 
1. generate our checkout compnent 
```shell
ng generate component components/checkout

```


2. add new route for checkout component 

```ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { FoodListComponent } from './components/food-list/food-list.component';
import { FoodService } from './services/food.service';
import { HttpClientModule } from '@angular/common/http';
import { NavbarComponent } from './components/navbar/navbar.component';
import { FooterComponent } from './components/footer/footer.component';
import { from } from 'rxjs';

import {Routes, RouterModule} from '@angular/router';
import { CategoryMenuComponent } from './components/category-menu/category-menu.component';
import { SearchComponent } from './components/search/search.component';

import { DetailComponent } from './components/detail/detail.component';

import { NgbModule } from '@ng-bootstrap/ng-bootstrap';
import { CartStatusComponent } from './components/cart-status/cart-status.component';
import { CartService } from './services/CartService';
import { CartDetailsComponent } from './components/cart-details/cart-details.component';

import {CheckoutComponent} from './components/checkout/checkout.component';
import { FormsModule,ReactiveFormsModule } from '@angular/forms';
 
const routes: Routes = [
  // PATH TO MATCH and when path matches create new instance of the component 
  {path: 'cart-details', component: CartDetailsComponent},
  {path:'food/:id', component: DetailComponent},

  {path: 'checkout', component: CheckoutComponent},
  {path: 'search/:keyword', component: FoodListComponent },
{path: 'category/:id', component: FoodListComponent},
{path: 'category', component: FoodListComponent},
{path: '', redirectTo:'', pathMatch:"full", component: FoodListComponent},
// this is one exception 
{path:'**', redirectTo:'',pathMatch:'full', component: FoodListComponent},
// this is a generic wildcard will match on anything that did not match above routes 

];
// the order of routes are important 

@NgModule({
  declarations: [
    AppComponent,
    FoodListComponent,
    NavbarComponent,
    FooterComponent,
    DetailComponent,
    CategoryMenuComponent,
    SearchComponent,
    CartStatusComponent,
    CartDetailsComponent,
    CheckoutComponent
 
  ],
  imports: [
    RouterModule.forRoot(routes),
    BrowserModule,
    HttpClientModule,
    NgbModule,
    ReactiveFormsModule,
    FormsModule
  ],
  providers: [FoodService, CartService],
  bootstrap: [AppComponent]
})
export class AppModule { }


```

3. create a new checkout button and link to checkout component 


```html

 <a routerLink="/checkout" class = "btn btn-primary"> Checkout </a>
    
```
that will take us to our given check out form 


4. add support for reactive forms in app.module.ts
```ts

  imports: [
    RouterModule.forRoot(routes),
    BrowserModule,
    HttpClientModule,
    NgbModule,
    ReactiveFormsModule
  ],
```


5. define form in component .ts file 
```ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';

@Component({
  selector: 'app-checkout',
  templateUrl: './checkout.component.html',
  styleUrls: ['./checkout.component.css']
})
export class CheckoutComponent implements OnInit {
  checkFormGroup!: FormGroup;

  constructor(private formBuilder: FormBuilder) { }

  ngOnInit(): void {
    this.checkFormGroup = this.formBuilder.group({
        customer: this.formBuilder.group({
          firstName: [''],
          lastName: [''],
          email:['']
        })

    })
  }

  onSubmit(){
    console.log("form has been submitted");
    console.log(this.checkFormGroup.get('customer')!.value);
  }

}


```


6. layout form controls in html template 
7. add event handler for form submission 
```html

<form [formGroup]="checkoutFormGroup" (ngSubmit)="onSubmit()">


    <div formGroupName="customer" class = "form-area">
      <h3> customer</h3>


      <div class = "row">
          <div class = "col-md-2"> <label> first name </label></div>
            <input formControlName = "firstName" type = "text">

            </div>
        

            <div class = "row">
        <div class = "col-md-2"> <label> last name </label></div>
        <input formControlName = "lastName" type = "text">
    </div>


    <div class = "row">
    <div class = "col-md-2"> <label> email </label></div>
    <input formControlName = "email" type = "text">
</div>
     


        <div class = "text-center">
<button type = "submit" class = "btn btn-info"> Purchase </button>
            </div>


        </div>




    </form>

```

it will output the data as json 

Can't bind to 'formGroup' since it isn't a known property of 'form'.:
   ReactiveFormsModule,
    FormsModule




we have basis here for doing form handling 

add shipping address

```html

<div class = "container">

<form [formGroup]="checkoutFormGroup" (ngSubmit)="onSubmit()">

 

        <!-- this is the user info -->
    <div formGroupName="customer" class = "form-area">
      <h3> customer</h3>


      <div class = "form-group">
          <div class = "col-md-2"> <label> first name </label></div>
            <input formControlName = "firstName" type = "text">

            </div>
        

            <div class = " form-group">
        <div class = "col-md-2"> <label> last name </label></div>
        <input formControlName = "lastName" type = "text">
    </div>


    <div class = " form-group">
    <div class = "col-md-2"> <label> email </label></div>
    <input formControlName = "email" type = "text">
</div>

</div>
     
<!-- this is the user info -->





        <!-- this is the shipping info -->
        <div formGroupName="shippingAddress" class = "form-area">
            <h3> Shipping info </h3>
      
      
            <div class = "form-group">
                <div class = "col-md-2"> <label> street name </label></div>
                  <input formControlName = "street" type = "text">
      
                  </div>
              
      
                  <div class = " form-group">
              <div class = "col-md-2"> <label> city name </label></div>
              <input formControlName = "city" type = "text">
          </div>
      
      
          <div class = " form-group">
          <div class = "col-md-2"> <label> province name </label></div>
          <input formControlName = "province" type = "text">
      </div>


      <div class = " form-group">
        <div class = "col-md-2"> <label> Zip Code </label></div>
        <input formControlName = "zipCode" type = "text">
    </div>
  
    </div>
           
      <!-- this is the shipping info -->



      

        <!-- this is the billing info -->
        <div formGroupName="billingAddress" class = "form-area">
            <h3> Shipping info </h3>
      
      
            <div class = "form-group">
                <div class = "col-md-2"> <label> street name </label></div>
                  <input formControlName = "street" type = "text">
      
                  </div>
              
      
                  <div class = " form-group">
              <div class = "col-md-2"> <label> city name </label></div>
              <input formControlName = "city" type = "text">
          </div>
      
      
          <div class = " form-group">
          <div class = "col-md-2"> <label> province name </label></div>
          <input formControlName = "province" type = "text">
      </div>


      <div class = " form-group">
        <div class = "col-md-2"> <label> Zip Code </label></div>
        <input formControlName = "zipCode" type = "text">
    </div>

    </div>
           
      <!-- this is the billing info -->



      

        <!-- this is the credit card info -->
        <div formGroupName="creditCard" class = "form-area">
            <h3> Credit Card Info </h3>
      
      
            <div class = "form-group">
                <div class = "col-md-2"> <label> Card Type </label></div>
                  <input formControlName = "cardType" type = "text">
      
                  </div>
              
      
                  <div class = " form-group">
              <div class = "col-md-2"> <label> name of card </label></div>
              <input formControlName = "nameOnCard" type = "text">
          </div>
      
      
          <div class = " form-group">
          <div class = "col-md-2"> <label> card number </label></div>
          <input formControlName = "cardNumber" type = "text">
      </div>


      <div class = " form-group">
        <div class = "col-md-2"> <label> Security Code </label></div>
        <input formControlName = "securityCode" type = "text">
    </div>



    <div class = " form-group">
        <div class = "col-md-2"> <label>  Expiratio Month </label></div>
        <input formControlName =  "expirationMonth" type = "text">
    </div>


    <div class = " form-group">
        <div class = "col-md-2"> <label>  Expiratio Year </label></div>
        <input formControlName =  "expirationYear" type = "text">
    </div>

    </div>
           
      <!-- this is the credit card info -->



        <div class = "text-center">
<button type = "submit" class = "btn btn-info"> Purchase </button>
            </div>


     


       



    </form>


    </div>
```





add check box to copy shipping to billing address 

```html

  <div class = "input-space">

        <label class = "au-checkbox">

            <input type = "checkbox" (onchange)="copyShippingtoBilling($event)">
           
        <span class = "au-checkmark"></span> billing address is same as shipping address
        </label>

        </div>
```


 Property 'shippingAddress' comes from an index signature, so it must be accessed with ['shippingAddress'].

 ```ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';

@Component({
  selector: 'app-checkout',
  templateUrl: './checkout.component.html',
  styleUrls: ['./checkout.component.css']
})
export class CheckoutComponent implements OnInit {
  checkoutFormGroup!: FormGroup;

  constructor(private formBuilder: FormBuilder) { }

  ngOnInit(): void {
    this.checkoutFormGroup = this.formBuilder.group({
        customer: this.formBuilder.group({
          firstName: [''],
          lastName: [''],
          email:['']
        }),
        shippingAddress: this.formBuilder.group({
          street: [''],
          city : [''],
          province : [''],
          zipCode: ['']
        }),
        billingAddress: this.formBuilder.group({
          street: [''],
          city : [''],
          province : [''],
          zipCode: ['']
        }),
        creditCard: this.formBuilder.group({
          cardType: [''],
          nameOnCard: [''],
          cardNumber: [''],
          securityCode: [''],
          expirationMonth: [''],
          expirationYear: ['']

        })

    })
  }

  onSubmit(){
    console.log("form has been submitted");
    console.log(this.checkoutFormGroup.get('customer')!.value);
  }

  copyShippingtoBilling(event: any){
  

    
    if(event.target!.checked){
     this.checkoutFormGroup.controls["billingAddress"].setValue(this.checkoutFormGroup.controls["shippingAddress"].value) ;
    }else{
      this.checkoutFormGroup.controls["billingAddress"].reset();
    }

  }

}

 ```



let's add the order review 
```html
  <div>
          <h3> reivew order </h3>
          <p> Total Quantity : {{totalQuantity}} </p>
          <p> Total Price : {{totalPrice}} </p>


        </div>
```


```ts
  totalPrice : number = 0;
  totalQuantity : number = 0;

```

# populating drop down list 

we could just hard code the values for dates but it is not ideal 

we would like to dynamically populate current year for the nxt 20 years 

we build a service 

ng generate service services/DateService



```ts
import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DateServiceService {

  constructor() { }

  getCreditCardMonths(startMonth: number) : Observable<number[]>{
    let data : number[] = [];
    for(let theMonth = startMonth; theMonth <= 12; theMonth ++){
      data.push(theMonth);
    }
    return of(data);
  };


  getCreditCardYears(): Observable<number[]>{
    let data: number [] = [];
    const startYear: number = 2020;
    const endYear: number = startYear + 20;

    for(let theYear = startYear; theYear < endYear; theYear ++){
      data.push(theYear);
      
    }
    return of(data);

  }


}



```

the of operator from the rjxs will wrap an object as an observable 


```ts

import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { DateServiceService } from 'src/app/services/date-service.service';

@Component({
  selector: 'app-checkout',
  templateUrl: './checkout.component.html',
  styleUrls: ['./checkout.component.css']
})
export class CheckoutComponent implements OnInit {
  checkoutFormGroup!: FormGroup;

  totalPrice : number = 0;
  totalQuantity : number = 0;

  creditCardMonths : number[] = [];
  creditCardYears : number[] = [];



  constructor(private formBuilder: FormBuilder, private dateService: DateServiceService) { }

  ngOnInit(): void {
    this.checkoutFormGroup = this.formBuilder.group({
        customer: this.formBuilder.group({
          firstName: [''],
          lastName: [''],
          email:['']
        }),
        shippingAddress: this.formBuilder.group({
          street: [''],
          city : [''],
          province : [''],
          zipCode: ['']
        }),
        billingAddress: this.formBuilder.group({
          street: [''],
          city : [''],
          province : [''],
          zipCode: ['']
        }),
        creditCard: this.formBuilder.group({
          cardType: [''],
          nameOnCard: [''],
          cardNumber: [''],
          securityCode: [''],
          expirationMonth: [''],
          expirationYear: ['']

        })

    })

    const startMonth: number = new Date().getMonth() + 1;
    this.dateService.getCreditCardMonths(startMonth).subscribe(
      data => {
        this.creditCardMonths = data;
      }
    );


    this.dateService.getCreditCardYears().subscribe(
      data => {
      
        this.creditCardYears = data;
        console.log("the years are " + this.creditCardYears);
      }
    );





  }

  onSubmit(){
    console.log("form has been submitted");
    console.log(this.checkoutFormGroup.get('customer')!.value);
  }

  copyShippingtoBilling(event: any){
  

    
    if(event.target!.checked){
     this.checkoutFormGroup.controls["billingAddress"].setValue(this.checkoutFormGroup.controls["shippingAddress"].value) ;
    }else{
      this.checkoutFormGroup.controls["billingAddress"].reset();
    }

  }

}


```



```html


    <div class = " form-group">
        <div class = "col-md-2"> <label>  Expiratio Month </label></div>
        <select formControlName =  "expirationMonth" >
     <option *ngFor="let item of creditCardMonths"> {{item}} </option>
            </select>
    </div>


    <div class = " form-group">
        <div class = "col-md-2"> <label>  Expiratio Year </label></div>
       

        <select formControlName =  "expirationYear" >
            <option *ngFor="let item of  creditCardYears"> {{item}} </option>
                   </select>
    </div>

```



## dependent fields 

fields should be dependent 
the values of month should depnd on the year 

values from month should deppend on the year 

if the current year is selected 
then only show the remaining months for the year 
start at current month to 12 

if a future year is selected 
then show months : 1-12 

1. update html tempalte 
for the expiration years dropdown list 
add event binding for change event 

2. update checkout component, add event handler 
read the selected year 
update the list of months based on selected year 

```html

 <select formControlName =  "expirationYear" (change)="handleMonthAndYears()" >
            <option *ngFor="let item of  creditCardYears"> {{item}} </option>
                   </select>
```



```ts

 handleMonthAndYears(){
    const creditCardFormGroup = this.checkoutFormGroup.get('creditCard');
    const currentYear: number = new Date().getFullYear();
    const selectedyear : number = Number(creditCardFormGroup?.value.expirationYear);
    let startMonth: number;

    if(currentYear === selectedyear){
      startMonth = new Date().getMonth() + 1;
    }else{
      startMonth = 1;

    }

    this.dateService.getCreditCardMonths(startMonth).subscribe(
      data => {
        this.creditCardMonths = data;
      }
    )
  }

```


## country and state dropdown list 

populate countries and states from the backend REST the user will select a country 
depend on country select, populate list of sate 
term state is different in each country similar to province 

we will continue to pop the country and state dropdown list 


the user will select a country, depending on country select, populate list of states 

1. create TypeScript clsas for Country and State 



create classes for country and states 
C:\Users\Eddie\Desktop\food\frontend\food-app>ng generate class common/state
CREATE src/app/common/state.spec.ts (150 bytes)
CREATE src/app/common/state.ts (23 bytes)

C:\Users\Eddie\Desktop\food\frontend\food-app>ng generate class common/country
CREATE src/app/common/country.spec.ts (158 bytes)
CREATE src/app/common/country.ts (25 bytes)

C:\Users\Eddie\Desktop\food\frontend\food-app>ng generate service services/CountryStateService

```ts

export class State {
    id: number;
    name:string;
}


export class Country {
    id:number;
    code:string;
    name:string;
}

```
2. add methods to the form service for countries and states 


```ts

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { map, Observable } from 'rxjs';
import { Country } from '../common/country';
import { State } from '../common/state';

@Injectable({
  providedIn: 'root'
})
export class CountryStateServiceService {
  private countriesURL = "http://localhost:8012/countries";
  private stateURL = "http://localhost:8012/state";

  constructor(private httpClient: HttpClient) { }

  getCountries():Observable<Country[]>{
    console.log(this.countriesURL);
    return this.httpClient.get<GetResponseCountries>(this.countriesURL).pipe(
      map(response => response._embedded.countries)
        );
      // returns an observable map the json data from spring data REST to country array 
  }

  getStates(theCountryCode: string): Observable<State[]>{
    const searchStateURL = `${this.stateURL}/search/findByCountryCode?code=${theCountryCode}`;

    console.log(searchStateURL);
  return this.httpClient.get<GetResponseStates>(searchStateURL).pipe(
    map(response => response._embedded.state)
  );
  }


}

interface GetResponseCountries{
  _embedded:{
    countries:Country[];
  }
  
}
interface GetResponseStates{
  _embedded:{
    state: State[];
  }
}

// returns an observable map the json data from spring data rest to array 



```

we need to import map, otherwise it shows:Cannot find name 'map'. Did you mean 'Map'?



3. update checkout component to retrive the countries from services 

4. update the html template to populate drop-down lists for countries 
```html

      
      <div class = " form-group">
        <div class = "col-md-2"> <label> country </label></div>
        <select formControlName = "country">

            <option *ngFor="let item of country" [ngValue]="item"  (change)="getStates('shippingAddress')" >
                {{item.name}}
                </option>

            </select>
    </div>

```

5. add event handler for checkout component 
read the selected country, retrieve list of states based on seleceted country 
update html template to populate dropdown lists for states 


```html
<div class = "container">

<form [formGroup]="checkoutFormGroup" (ngSubmit)="onSubmit()">

 

        <!-- this is the user info -->
    <div formGroupName="customer" class = "form-area">
      <h3> customer</h3>


      <div class = "form-group">
          <div class = "col-md-2"> <label> first name </label></div>
            <input formControlName = "firstName" type = "text">

            </div>
        

            <div class = " form-group">
        <div class = "col-md-2"> <label> last name </label></div>
        <input formControlName = "lastName" type = "text">
    </div>


    <div class = " form-group">
    <div class = "col-md-2"> <label> email </label></div>
    <input formControlName = "email" type = "text">
</div>

</div>
     
<!-- this is the user info -->





        <!-- this is the shipping info -->
        <div formGroupName="shippingAddress" class = "form-area">
            <h3> Shipping info </h3>
      
      
            <div class = "form-group">
                <div class = "col-md-2"> <label> street name </label></div>
                  <input formControlName = "street" type = "text">
      
                  </div>
              
      
                  <div class = " form-group">
              <div class = "col-md-2"> <label> city name </label></div>
              <input formControlName = "city" type = "text">
          </div>
      
          
      <div class = " form-group">
        <div class = "col-md-2"> <label> country </label></div>
        <select formControlName = "country" (change)="getStates('shippingAddress')" >

            <option *ngFor=" let item of country" [ngValue]="item">
               {{item.name}}
                </option>

            </select>
    </div>

      
          <div class = " form-group">
          <div class = "col-md-2"> <label> province name </label></div>
          <select formControlName = "province" >
            <option *ngFor="let item of  shippingAddressStates" [ngValue]="item" (change)="getStates('shippingAddress')">
              {{item.name}}
              </option>
              </select> 
        </div>
 



      <div class = " form-group">
        <div class = "col-md-2"> <label> Zip Code </label></div>
        <input formControlName = "zipCode" type = "text">
    </div>
  
    </div>
           
      <!-- this is the shipping info -->



      <!-- check box to copy shipping to billing -->
    <div>

        <label>

            <input type = "checkbox" (change)="copyShippingtoBilling($event)">
           
         billing address is same as shipping address
        </label>

        </div>


            <!-- check box to copy shipping to billing -->


        <!-- this is the billing info -->
        <div formGroupName="billingAddress" class = "form-area">
            <h3> Billing info </h3>
      
      
            <div class = "form-group">
                <div class = "col-md-2"> <label> street name </label></div>
                  <input formControlName = "street" type = "text">
      
                  </div>
              
      
                  <div class = " form-group">
              <div class = "col-md-2"> <label> city name </label></div>
              <input formControlName = "city" type = "text">
          </div>
      
      
          

      
      <div class = " form-group">
        <div class = "col-md-2"> <label> country </label></div>
        <select formControlName = "country" (change)="getStates('billingAddress')">

            <option *ngFor="let item of country" [ngValue]="item"   >
                {{item.name}}
                </option>

            </select>
    </div>

    <div class = " form-group">
        <div class = "col-md-2"> <label> province </label></div>
     
      <select formControlName = "province" >
        <option *ngFor="let item of  billingAddressStates" [ngValue]="item" >
          {{item.name}}
          </option>
          </select> 
    </div>


      <div class = " form-group">
        <div class = "col-md-2"> <label> Zip Code </label></div>
        <input formControlName = "zipCode" type = "text">
    </div>

    </div>
           
      <!-- this is the billing info -->



      

        <!-- this is the credit card info -->
        <div formGroupName="creditCard" class = "form-area">
            <h3> Credit Card Info </h3>
      
      
            <div class = "form-group">
                <div class = "col-md-2"> <label> Card Type </label></div>
                  <input formControlName = "cardType" type = "text">
      
                  </div>
              
      
                  <div class = " form-group">
              <div class = "col-md-2"> <label> name of card </label></div>
              <input formControlName = "nameOnCard" type = "text">
          </div>
      
      
          <div class = " form-group">
          <div class = "col-md-2"> <label> card number </label></div>
          <input formControlName = "cardNumber" type = "text">
      </div>


      <div class = " form-group">
        <div class = "col-md-2"> <label> Security Code </label></div>
        <input formControlName = "securityCode" type = "text">
    </div>



    <div class = " form-group">
        <div class = "col-md-2"> <label>  Expiration Month </label></div>
        <select formControlName =  "expirationMonth" >
     <option *ngFor="let item of creditCardMonths"> {{item}} </option>
            </select>
    </div>


    <div class = " form-group">
        <div class = "col-md-2"> <label>  Expiration Year </label></div>
       

        <select formControlName =  "expirationYear" (change)="handleMonthAndYears()" >
            <option *ngFor="let item of  creditCardYears"> {{item}} </option>
                   </select>
    </div>

    </div>
           
      <!-- this is the credit card info -->


      <!-- order details -->

      <div>
          <h3> reivew order </h3>
          <p> Total Quantity : {{totalQuantity}} </p>
          <p> Total Price : {{totalPrice}} </p>


        </div>


      <!--order details -->


        <div class = "text-center">
<button type = "submit" class = "btn btn-info"> Purchase </button>
            </div>


     


       



    </form>


    </div>

```


```ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { Country } from 'src/app/common/country';
import { State } from 'src/app/common/state';
import { CountryStateServiceService } from 'src/app/services/country-state-service.service';
import { DateServiceService } from 'src/app/services/date-service.service';

@Component({
  selector: 'app-checkout',
  templateUrl: './checkout.component.html',
  styleUrls: ['./checkout.component.css']
})
export class CheckoutComponent implements OnInit {
  checkoutFormGroup!: FormGroup;

  totalPrice : number = 0;
  totalQuantity : number = 0;

  creditCardMonths : number[] = [];
  creditCardYears : number[] = [];

  country: Country[] = [];

  state: State[] =[];


  shippingAddressStates: State[] = [];
  billingAddressStates : State[] = [];




  constructor(private formBuilder: FormBuilder, private dateService: DateServiceService, private countryStateService: CountryStateServiceService) { }

  ngOnInit(): void {

    this.countryStateService.getCountries().subscribe(
      data => {
        this.country = data;
      }
    );

 




    this.checkoutFormGroup = this.formBuilder.group({
        customer: this.formBuilder.group({
          firstName: [''],
          lastName: [''],
          email:['']
        }),
        shippingAddress: this.formBuilder.group({
          street: [''],
          city : [''],
          province : [''],
          country:[''],
          zipCode: ['']
        }),
        billingAddress: this.formBuilder.group({
          street: [''],
          city : [''],
          province : [''],
          country:[''],
          zipCode: ['']
        }),
        creditCard: this.formBuilder.group({
          cardType: [''],
          nameOnCard: [''],
          cardNumber: [''],
          securityCode: [''],
          expirationMonth: [''],
          expirationYear: ['']

        })

    })

    const startMonth: number = new Date().getMonth() + 1;
    this.dateService.getCreditCardMonths(startMonth).subscribe(
      data => {
        this.creditCardMonths = data;
      }
    );


    this.dateService.getCreditCardYears().subscribe(
      data => {
      
        this.creditCardYears = data;
        console.log("the years are " + this.creditCardYears);
      }
    );





  }

  onSubmit(){
    console.log("form has been submitted");
    console.log(this.checkoutFormGroup.get('customer')!.value);
  }

  copyShippingtoBilling(event: any){
  

    
    if(event.target!.checked){
     this.checkoutFormGroup.controls["billingAddress"].setValue(this.checkoutFormGroup.controls["shippingAddress"].value) ;
    }else{
      this.checkoutFormGroup.controls["billingAddress"].reset();
    }

  }


  handleMonthAndYears(){
    const creditCardFormGroup = this.checkoutFormGroup.get('creditCard');
    const currentYear: number = new Date().getFullYear();
    const selectedyear : number = Number(creditCardFormGroup?.value.expirationYear);
    let startMonth: number;

    if(currentYear === selectedyear){
      startMonth = new Date().getMonth() + 1;
    }else{
      startMonth = 1;

    }

    this.dateService.getCreditCardMonths(startMonth).subscribe(
      data => {
        this.creditCardMonths = data;
      }
    )
  }

  getStates(formGroupName: string){
    const formGroup = this.checkoutFormGroup.get(formGroupName);
    const countryCode = formGroup?.value.country.code;

    this.countryStateService.getStates(countryCode).subscribe(
    data => {
      if(formGroupName === "shippingAddress"){
        this.shippingAddressStates = data;

      }else{
        this.billingAddressStates = data;

      }

      formGroup?.get('state')?.setValue(data[0]);
   
    }
    );

  }

  
}

  
```

we will add validations to our checkout forms 
before we submit the form to the backend, let's perform validation 

check for required fields, min length and etc 

angular has a set of built in validation rules 

required: must be a non empty value 
min : must be a number >= value 
max: must be a number <= value
minLength: length must be >= value 
maxLength Length must be <= value 
pattern must match a regular expression pattern 
email: must match email against common regular expression patterns 
and there are other validation rules 


1. define custom validators 
2. cross field validation
3. asynchronous validators 


checkout form validation
our requirements: 
all fields are rquired
email address has proper email format 
credit card fields only numbers allowed 16 digits 
cvc numbers, only numbers are allowed 3 digits 

1. specify validation rules for the form control
recall that a form field is represented by FormControl object
create the FormControl and pass in initial value and validators 
```ts
new FormControl(initialValue, validators,...)
new FormControl('', [Validators.required, Validators.minLength(2)])
```

```ts



    this.checkoutFormGroup = this.formBuilder.group({
        customer: this.formBuilder.group({
          'firstName': new FormControl('',[Validators.required, Validators.minLength(2)]),
          'lastName': new FormControl('',[Validators.required,Validators.minLength(2)]),
          'email': new FormControl('',[Validators.required,Validators.pattern('^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$')])
        }),
        shippingAddress: this.formBuilder.group({
          street: [''],
```
2. define getter methods to access form controls 
in checkout.component.ts

```ts
 

  get firstName(){
    return this.checkoutFormGroup.get('customer.firstName');
  }

  get lastName(){
    return this.checkoutFormGroup.get('customer.lastName');
  }

  get email(){
    return this.checkoutFormGroup.get('customer.email');
  }

```


3. update html template to display error messages 
```html

   <div *ngIf = "firstName?.invalid" && (firstName.dirty || firstName.touched) class = "alert alert-danger">
  <div *ngIf="firstName.errors?.['required']">

    FirstName is required 
    </div>
    <div *ngIf="firstName.errors?.['minlength']">
       First Name must be at least 2 characters long 
        </div>
        </div>
```
angular error.required Object is possibly 'null'.

```html

      <div class = "form-group">
          <div class = "col-md-2"> <label> first name </label></div>
             <input formControlName = "firstName" type = "text">
   <div *ngIf = "firstName?.invalid" && (firstName.dirty || firstName.touched) class = "alert alert-danger">
  <div *ngIf="firstName?.hasError('required')">

    FirstName is required 
    </div>
    <div *ngIf="firstName?.hasError('minlength')">
       First Name must be at least 2 characters long 
        </div>
        </div>

            </div>
        
```
only display validation errors if user has interacted with the form 
- when the user changse field value, the control is marked as dirty 
- when the filed loses focus, the control is marked as touched 

attribute.dirty: did user change field value 
attribute.touched: did field lose focus? 
we need to find out which specific validation failed here 

```html


  
      <div class = "form-group">
          <div class = "col-md-2"> <label> first name </label></div>
             <input formControlName = "firstName" type = "text">
   <div *ngIf = "firstName?.invalid && (firstName?.dirty || firstName?.touched)" class = "alert alert-danger">
  <div *ngIf="firstName?.hasError('required')">

    FirstName is required 
    </div>
    <div *ngIf="firstName?.hasError('minlength')">
       First Name must be at least 2 characters long 
        </div>
        </div>

            </div>
        

            <div class = " form-group">
        <div class = "col-md-2"> <label> last name </label></div>
        <input formControlName = "lastName" type = "text">
    <div *ngIf="lastName?.invalid && (lastName?.dirty || lastName?.touched)" class = "alert alert-danger">
     <div *ngIf = "lastName?.hasError('required')">
      last name is required 
        </div>
        <div *ngIf = "lastName?.hasError('minlength')">
        last name must have the length greater than 2    
        </div>

        </div>
    
    
    </div>


    <div class = " form-group">
    <div class = "col-md-2"> <label> email </label></div>
    <input formControlName = "email" type = "text">
    <div *ngIf="email?.invalid && (email?.dirty || email?.touched)" class="alert alert-danger">
    <div *ngIf="email?.hasError('required')">
        email is required 
        </div>

        <div *ngIf="email?.hasError('pattern')">
            email is not valid
            </div>
    


        </div>
        

```



4. add event handler to check validation status when submit button clicked 
```ts

  onSubmit(){
    if(this.checkoutFormGroup.invalid){
      this.checkoutFormGroup.markAllAsTouched();
    }
    

  }

```
touching all fields triggers the display of error messages 


we will take this as is 




you may wonder why we are not using Validators.email? 
Validators.email only checks for the basic txt@txt based on this , xx@xx is a valid email address 
it does not check for domain name format . as a result we use a regular exprssion with Validators.pattern it was too lenient. Validators and Validators.pattern only check the FORMAT does not verify if the email address is real 

### whitespace 
our form currently has a problem with white spaces, in the required fields, if we enter only whitespace it passed yikes, it should fail , the validation goes away 


custom validator 

we can resolve this with a custom validtor: notOnlyWhitespace 
check the field value, if it only has whitespace , then return an error failed, else return null passed


1. define custom validator rule in the xxxvalidator.ts 
ng generate class validators/xxxvalidtor

```ts
import { FormControl, ValidationErrors } from "@angular/forms";

export class OrderValidator {

    static notOnlyWhiteSpace(control: FormControl) : ValidationErrors{

        if((control.value != null) && (control.value.trim().length === 0)){
            return {'notOnlyWhitespace': true};
        }else{
            return {'notOnlyWhitespace': false};
        }
    }

}

```
if the validation check fails then return validation errors, if validation check passes then return null 



Function lacks ending return statement and return type does not include 'undefined'.


```ts

import { FormControl, ValidationErrors } from "@angular/forms";

export class OrderValidator {

    static notOnlyWhiteSpace(control: FormControl) : ValidationErrors | null{

        if((control.value != null) && (control.value.trim().length === 0)){
            return {'notOnlyWhitespace': true};
        }else{
            return  null;
        }
    }

}

```

2. specify custom validator rule for form controls 


```html

<div *ngIf="firstName?.hasError('minlength')">
       First Name must be at least 2 characters long 
        </div>
        </div>

            </div>
        

            <div class = " form-group">
        <div class = "col-md-2"> <label> last name </label></div>
        <input formControlName = "lastName" type = "text">
    <div *ngIf="lastName?.invalid && (lastName?.dirty || lastName?.touched)" class = "alert alert-danger">
     <div *ngIf = "lastName?.hasError('required') || lastName?.hasError('notOnlyWhitespace')">
      last name is required 
        </div>
        <div *ngIf = "lastName?.hasError('minlength')">
        last name must have the length greater than 2    
        </div>
```

we have our custom validation up and runnign and our validation is in place 


finishing up the remaining sections 

development process 

1. specify validation rules for the form controls 

```ts

    this.checkoutFormGroup = this.formBuilder.group({
        customer: this.formBuilder.group({
          'firstName': new FormControl('',[Validators.required, Validators.minLength(2), OrderValidator.notOnlyWhiteSpace]),
          'lastName': new FormControl('',[Validators.required,Validators.minLength(2), OrderValidator.notOnlyWhiteSpace]),
          'email': new FormControl('',[Validators.required,Validators.pattern('^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$')])
        }),
        shippingAddress: this.formBuilder.group({
          'street':  new FormControl('',[Validators.required,Validators.minLength(2), OrderValidator.notOnlyWhiteSpace]),
          'city' :  new FormControl('',[Validators.required,Validators.minLength(2), OrderValidator.notOnlyWhiteSpace]),
          province : [''],
          country:[''],
          'zipCode':  new FormControl('',[Validators.required,Validators.minLength(2), OrderValidator.notOnlyWhiteSpace])
        }),

```
2. define getter methods to access for controls 
```ts

  get shippingAddressStreet(){
    return this.checkoutFormGroup.get('shippingAddress.street');
  }

  get shippingAddressCity(){
    return this.checkoutFormGroup.get('shippingAddress.city');
  }

   
  
  get shippingAddressZipCode(){
    return this.checkoutFormGroup.get('shippingAddress.zipCode');
  }



```
3. update html tempalte to display error messages 
```html


        <!-- this is the shipping info -->
        <div formGroupName="shippingAddress" class = "form-area">
            <h3> Shipping info </h3>
      
      
            <div class = "form-group">
                <div class = "col-md-2"> <label> shippingAddressStreet name </label></div>
                  <input formControlName = "street" type = "text">
                  <div *ngIf="shippingAddressStreet?.invalid && (shippingAddressStreet?.dirty || shippingAddressStreet?.touched)" class = "alert alert-danger">
                    <div *ngIf = "shippingAddressStreet?.hasError('required') || shippingAddressStreet?.hasError('notOnlyWhitespace')">
                        shippingAddressStreet is required 
                       </div>
                       <div *ngIf = "shippingAddressStreet?.hasError('minlength')">
                        shippingAddressStreet must have the length greater than 2    
                       </div>
               
                       </div>
                   
      
                  </div>
              
      
                  <div class = " form-group">
                    <div class = "col-md-2"> <label> shippingAddressCity name </label></div>
                    <input formControlName = "city" type = "text">
                    <div *ngIf="shippingAddressCity?.invalid && (shippingAddressCity?.dirty || shippingAddressCity?.touched)" class = "alert alert-danger">
                        <div *ngIf = "shippingAddressCity?.hasError('required') || shippingAddressCity?.hasError('notOnlyWhitespace')">
                            shippingAddressCity is required 
                           </div>
                           <div *ngIf = "shippingAddressCity?.hasError('minlength')">
                            shippingAddressCity must have the length greater than 2    
                           </div>
                   
                           </div>
               
            </div>
      
          
      <div class = " form-group">
        <div class = "col-md-2"> <label> country </label></div>
        <select formControlName = "country" (change)="getStates('shippingAddress')" >

            <option *ngFor=" let item of country" [ngValue]="item">
               {{item.name}}
                </option>

            </select>
            
    </div>

      
          <div class = " form-group">
          <div class = "col-md-2"> <label> province name </label></div>
          <select formControlName = "province" >
            <option *ngFor="let item of  shippingAddressStates" [ngValue]="item" (change)="getStates('shippingAddress')">
              {{item.name}}
              </option>
              </select> 
        </div>
 



      <div class = " form-group">
        <div class = "col-md-2"> <label> Zip Code </label></div>
        <input formControlName = "zipCode" type = "text">
   
        <div *ngIf="shippingAddressZipCode?.invalid && (shippingAddressZipCode?.dirty || shippingAddressZipCode?.touched)" class = "alert alert-danger">
            <div *ngIf = "shippingAddressZipCode?.hasError('required') || shippingAddressZipCode?.hasError('notOnlyWhitespace')">
                shippingAddressZipCode is required 
               </div>
               <div *ngIf = "shippingAddressZipCode?.hasError('minlength')">
                shippingAddressZipCode must have the length greater than 2    
               </div>
       
               </div>
           
    </div>
  
    </div>
           
      <!-- this is the shipping info -->



      <!-- check box to copy shipping to billing -->
    <div>

        <label>

            <input type = "checkbox" (change)="copyShippingtoBilling($event)">
           
         billing address is same as shipping address
        </label>

        </div>


            <!-- check box to copy shipping to billing -->


        <!-- this is the billing info -->
        <div formGroupName="billingAddress" class = "form-area">
            <h3> Billing info </h3>
      
      
            <div class = "form-group">
                <div class = "col-md-2"> <label> street name </label></div>
                  <input formControlName = "street" type = "text">
                  <div *ngIf="billingAddressStreet?.invalid && (billingAddressStreet?.dirty || billingAddressStreet?.touched)" class = "alert alert-danger">
                    <div *ngIf = "billingAddressStreet?.hasError('required') || billingAddressStreet?.hasError('notOnlyWhitespace')">
                        billingAddressStreet is required 
                       </div>
                       <div *ngIf = "billingAddressStreet?.hasError('minlength')">
                        billingAddressStreet must have the length greater than 2    
                       </div>
               
                       </div>
                  </div>
              
      
                  <div class = " form-group">
              <div class = "col-md-2"> <label> city name </label></div>
              <input formControlName = "city" type = "text">
              <div *ngIf="billingAddressCity?.invalid && (billingAddressCity?.dirty || billingAddressCity?.touched)" class = "alert alert-danger">
                <div *ngIf = "billingAddressCity?.hasError('required') || billingAddressCity?.hasError('notOnlyWhitespace')">
                    billingAddressCity is required 
                   </div>
                   <div *ngIf = "billingAddressCity?.hasError('minlength')">
                    billingAddressCity must have the length greater than 2    
                   </div>
           
                   </div>

            </div>
      
      
          

      
      <div class = " form-group">
        <div class = "col-md-2"> <label> country </label></div>
        <select formControlName = "country" (change)="getStates('billingAddress')">

            <option *ngFor="let item of country" [ngValue]="item"   >
                {{item.name}}
                </option>

            </select>
    </div>

    <div class = " form-group">
        <div class = "col-md-2"> <label> province </label></div>
     
      <select formControlName = "province" >
        <option *ngFor="let item of  billingAddressStates" [ngValue]="item" >
          {{item.name}}
          </option>
          </select> 
    </div>


      <div class = " form-group">
        <div class = "col-md-2"> <label> Zip Code </label></div>
        <input formControlName = "zipCode" type = "text">
        <div *ngIf="billingAddressZipCode?.invalid && (billingAddressZipCode?.dirty || billingAddressZipCode?.touched)" class = "alert alert-danger">
            <div *ngIf = "billingAddressZipCode?.hasError('required') || billingAddressZipCode?.hasError('notOnlyWhitespace')">
                billingAddressZipCode is required 
               </div>
               <div *ngIf = "billingAddressZipCode?.hasError('minlength')">
                billingAddressZipCode must have the length greater than 2    
               </div>
       
               </div>

    </div>

    </div>
```


billing address validation 

```ts
  billingAddress: this.formBuilder.group({
          'street':  new FormControl('',[Validators.required,Validators.minLength(2), OrderValidator.notOnlyWhiteSpace]),
          'city' :  new FormControl('',[Validators.required,Validators.minLength(2), OrderValidator.notOnlyWhiteSpace]),
          province : [''],
          country:[''],
          'zipCode':  new FormControl('',[Validators.required,Validators.minLength(2), OrderValidator.notOnlyWhiteSpace])
        }),

```




 



we will check the credit card with 16 digits using a regular expression 



```ts
    creditCard: this.formBuilder.group({
          cardType: new FormControl('',[Validators.required]),
          nameOnCard: new FormControl('',[Validators.required, Validators.minLength(2)]),
          cardNumber: new FormControl('',[Validators.required, Validators.pattern('[0-9]{16}')] ),
          securityCode: new FormControl('',[Validators.required, Validators.pattern('[0-9]{3}')] ),
          expirationMonth: [''],
          expirationYear: ['']

        })



  get creditCardType(){
    return this.checkoutFormGroup.get('creditCard.cardType');

  }


  
 

  
  get creditCardNameOnCard(){
    return this.checkoutFormGroup.get('creditCard.nameOnCard');
    
  }

  get creditCardNumber(){
    return this.checkoutFormGroup.get('creditCard.cardNumber');
    
  }

  get creditCardSecurityCode(){
    return this.checkoutFormGroup.get('creditCard.securityCode');
    
  }


```



```ts

        <!-- this is the credit card info -->
        <div formGroupName="creditCard" class = "form-area">
            <h3> Credit Card Info </h3>
      
      
            <div class = "form-group">
                <div class = "col-md-2"> <label> Card Type </label></div>
                 

                  <select formControlName = "cardType">

                    <option>Visa </option>
                    <option>Master </option>
        
                    </select>

                    <div *ngIf="creditCardType?.invalid && (creditCardType?.dirty || creditCardType?.touched)" class = "alert alert-danger">
                        <div *ngIf = "creditCardType?.hasError('required') || creditCardType?.hasError('notOnlyWhitespace')">
                            creditCardType is required 
                           </div>
                           <div *ngIf = "creditCardType?.hasError('minlength')">
                            creditCardType must have the length greater than 2    
                           </div>
                   
                           </div>
                   
      
                  </div>
              
      
                  <div class = " form-group">
              <div class = "col-md-2"> <label> name of card </label></div>
              <input formControlName = "nameOnCard" type = "text">

              <div *ngIf="creditCardNameOnCard?.invalid && (creditCardNameOnCard?.dirty || creditCardNameOnCard?.touched)" class = "alert alert-danger">
                <div *ngIf = "creditCardNameOnCard?.hasError('required') || creditCardNameOnCard?.hasError('notOnlyWhitespace')">
                    creditCardNameOnCard is required 
                   </div>
                   <div *ngIf = "creditCardNameOnCard?.hasError('minlength')">
                    creditCardNameOnCard must have the length greater than 2    
                   </div>
           
                   </div>




          </div>
      
      
          <div class = " form-group">
          <div class = "col-md-2"> <label> card number </label></div>
          <input formControlName = "cardNumber" type = "text">

          <div *ngIf="creditCardNumber?.invalid && (creditCardNumber?.dirty || creditCardNumber?.touched)" class = "alert alert-danger">
            <div *ngIf = "creditCardNumber?.hasError('required') || creditCardNumber?.hasError('notOnlyWhitespace')">
                creditCardNumber is required 
               </div>
               <div *ngIf = "creditCardNumber?.hasError('pattern')">
                creditCardNumber must have the length of 16 digits  
               </div>
       
               </div>
      </div>


      <div class = " form-group">
        <div class = "col-md-2"> <label> Security Code </label></div>
        <input formControlName = "securityCode" type = "text">

        <div *ngIf="creditCardSecurityCode?.invalid && (creditCardSecurityCode?.dirty || creditCardSecurityCode?.touched)" class = "alert alert-danger">
            <div *ngIf = "creditCardSecurityCode?.hasError('required') || creditCardSecurityCode?.hasError('notOnlyWhitespace')">
                creditCardSecurityCode is required 
               </div>
               <div *ngIf = "creditCardSecurityCode?.hasError('pattern')">
                creditCardSecurityCode must have the length of 3 digits  
               </div>
       
               </div>
        
       




    </div>

```



update checkout cart totals 

our form currently has a section for cart totals 
we need to add the appropriate code to support this 

the cart service publishing messages/events
recall that we have messages/events to other components 

the CartSttausComponent will subscribe to the artService 

the CartService will publish messages for totalPrice and totalQuantiy 

refresher 

productlist

cartstatuscomponent 
1. subscribe for events 

cartservice 
2. addtocart to productlist 
cart service will
3. publish events to all subscribers 
4. update ui for cart status for total price and quantity 


```ts
export class CartService{

    cartItem: CartItem[] = [];

    totalPrice : Subject<number> = new Subject<number>();
    totalQuantity: Subject<number> = new Subject<number>();

    


```

subject is a subclass for observable 
we can use subject to publish events in our code 
the event will be sent to all of the subscribers 


```ts

    computeTotals(){
        let totalPriceValue : number = 0;
        let totalQuantityValue : number = 0;

        console.log("currentItem length:" + this.cartItem.length);
       

        for(let currentCartItem of this.cartItem){
            totalPriceValue += currentCartItem.quantity * currentCartItem.price;
            totalQuantityValue += currentCartItem.quantity;

            console.log(`current item quantity is ${currentCartItem.price}`);
        }

        this.totalPrice.next(totalPriceValue);
        this.totalQuantity.next(totalQuantityValue);

        console.log(`the total price is ${totalPriceValue}`);
        console.log(`the total quantity is ${totalQuantityValue}`);
        // publish the new values all sucbribers will receive the new data and update real time 
        // next method push and send events 
    }

```


this will publish events to all subscribers 
one event for total price 
one event for total quantity 


```ts

export class CartStatusComponent implements OnInit {

  totalPrice : number = 0.00;
  totalQuantity : number = 0;


  constructor(private cartService: CartService) { }

  ngOnInit(): void {
    this.updateCartStatus();
    
  }

  updateCartStatus(){
    this.cartService.totalPrice.subscribe(
      (data) => {this.totalPrice = data;
      this.totalPrice = +this.totalPrice.toFixed(2);}
    )

    this.cartService.totalQuantity.subscribe(
      (data) => {this.totalQuantity = data;
      }
    )
  }

}
```


when new events are received make the assignemnts to update UI  accodringly 

we already have these in place 
just to give you a quick refresh to kind of get you back to speed 


### publish / subscribe 

similar approach for checkout component 

checkoutcomponent will subscribe to ents from cart service 

however, since checkout component is instantiated later in the app 
it will miss out on previous messages 


as a result, checkout component cart total will erroneously show as 
0 for total quantity 
0.00 for total price 


we need to get a replay of messages missed 

### replay messages 
## ReplaySubject
recall, subject is used to send events to subscribers 
ReplaySubject is a subclass of Subject 
it will also replay events for new subscribers who join later 
it keeps a buffer of previous events and send to new subscribers 
can you tell me what I missed?? 

CartService TotalPrice Subject 
/\                   |
 | subscribe         |
CartStatusComponent 
 /\                  |
  | subscribe()      \/
checkoutComponent 

received these because of replay 


## Subject without replay 

CartService TotalPrice Subject 
/\
 | subscribe
CartStatusComponent 
 /\
  | subscribe()
checkoutComponent 



```ts
export class CartService{
  cartIem: CartItem[] = [];
  totalPrice : Subject<number> = new ReplaySubject<number>();
  totalQuantity: Subject<number> = new ReplaySubject<number>();

}

```

keep a buffer of previous event, send previous ents to new subscribers 


but wait, there is another solution
at first glance, ReplaySubject seems like the perfect solution 
However, for totals, we really do not need to replay the previous otals 
we are only interested in the latest totals , we do not care immediate 

## BehaviorSubject 
BehaviorSubject is a subclass of Subject
 has a notion of current value 
 stores the latest message/event and sends to new subscribers 


 BehaviourSubject are useful for representing values over time 
 for instance, an event stream of birthday is a Subject
 but the stream of a person's age would be a BehaviourSubject 


CartService TotalPrice BehaviorSubject 
/\                      |
 | subscribe            |
CartStatusComponent     |
 /\                     |
  | subscribe()         |
checkoutComponent       receive the latest messages 

```ts
export class CartService{
  cartIem: CartItem[] = [];
  totalPrice : Subject<number> = new BehaviorSubject<number>(0);
  totalQuantity: Subject<number> = new BehaviorSubject<number>(0);

}

```


# Recap
Subject: does not keep a buffer of previous events , subscribers only receives new events after they are subscribed 

ReplaySubject: jas a buffer of all previous events, once subscribed, subscribers receives a replay of all previous events 


BehaviorSubject: has a buffer of the last event, once subscribed , subscriber receives the latest event sent prior to subscribing 


development process 
1. update for CheckoutComponent
inject CartService into CheckoutComponent 
2. in ngOnit method, call new methods : reviewCartDetails()
3. add code for new method: reviewCartDetails() 


2. update for CartService 

```ts

  constructor(private formBuilder: FormBuilder, private dateService: DateServiceService, private countryStateService: CountryStateServiceService, private cartService: CartService) { }


  reviewCartDetails(){
    this.cartService.totalQuantity.subscribe(
      totalQuantity => this.totalQuantity = totalQuantity
    );

    this.cartService.totalPrice.subscribe(
      totalPrice => this.totalPrice = totalPrice
    );

      
  }
```



```ts

export class CartService{

    cartItem: CartItem[] = [];

    totalPrice : Subject<number> = new BehaviorSubject<number>(0);
    totalQuantity: Subject<number> = new BehaviorSubject<number>(0);

    
```


set initial value total price = 0 total quantity = 0





save the order 

the spring boot backend code is up and running 
let's focus on developing angular front-end 

1. create common classes 
customer, order, OrderItem, Address, Purchase 

2. Create CheckoutService 
make REST API call to spring boot backend 

3. update checkout component 
inject checkout service and router 
update on submit() method to collect from data call checkout service 

ng generate class common/Customer  
ng generate class common/Order
ng generate class common/OrderItem
ng generate class common/Address
ng generate class common/Purchase



```ts

export class Order {
    totalQuantity : number;
    totalPrice: number;
    
}


export class Customer {
    firstName: string;
    lastName: string;
    phone: string;
    balance: number;
    moneySpent : number;
    dateOfBirth: Date;
    email: string;
    signature: string;
    accountCreated : Date;
    
    
 
}
import { CartItem } from "./CartItem";

export class OrderItem {
    imageUrl: string;
    unitPrice: number;
    quantity: number;
    foodId: string;

    constructor(cartItem : CartItem){
        this.imageUrl = cartItem.imageUrl;
        this.quantity = cartItem.quantity;
        this.unitPrice = cartItem.unitPrice;
        this.foodId = cartItem.foodId;
        
    }
}


export class Address {
    street : string;
    city: string;
    state: string;
    country: string;
    zipCode: string;
}

import { Address } from "./address";
import { Customer } from "./customer";
import { Order } from "./order";
import { OrderItem } from "./order-item";

export class Purchase {
    customer: Customer;
    shippingAddress: Address;
    billingAddress: Address;
    order: Order;
    orderItem: OrderItem[];
}


```

create checkout service make rest api call to spring boot backend 






ng generate service services/Checkout

```ts

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { Purchase } from '../common/purchase';

@Injectable({
  providedIn: 'root'
})
export class CheckoutService {
  private purchaseURL = 'http://localhost:8012/checkout/purchase';

  constructor(private httpClient: HttpClient) {


   }

   placeOrder(purchase: Purchase) : Observable<any>{
     return this.httpClient.post<Purchase>(this.purchaseURL,purchase);
     

   }
}

```


```ts

import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { Country } from 'src/app/common/country';
import { State } from 'src/app/common/state';
import { CartService } from 'src/app/services/CartService';
import { CheckoutService } from 'src/app/services/checkout.service';
import { CountryStateServiceService } from 'src/app/services/country-state-service.service';
import { DateServiceService } from 'src/app/services/date-service.service';
import { OrderValidator } from 'src/app/validator/order-validator';

@Component({
  selector: 'app-checkout',
  templateUrl: './checkout.component.html',
  styleUrls: ['./checkout.component.css']
})
export class CheckoutComponent implements OnInit {
  checkoutFormGroup!: FormGroup;

  totalPrice : number = 0;
  totalQuantity : number = 0;

  creditCardMonths : number[] = [];
  creditCardYears : number[] = [];

  country: Country[] = [];

  state: State[] =[];


  shippingAddressStates: State[] = [];
  billingAddressStates : State[] = [];




  constructor(private formBuilder: FormBuilder, private dateService: DateServiceService, private countryStateService: CountryStateServiceService, private cartService: CartService, private checkoutService: CheckoutService, private router: Router) { }


```


```ts


import { Food } from "./food";
export class CartItem{
    id: number;
    name : string;

    imageUrl: string;

    unitPrice: number;

    foodId: string;
 
    price: number;
    quantity: number;

    constructor(food: Food){
        this.id = food.id;
        this.name = food.foodName;
  
        this.price = food.price;
        this.quantity = food.quantity;

    }
}
```


```ts

  onSubmit(){
    if(this.checkoutFormGroup.invalid){
      this.checkoutFormGroup.markAllAsTouched();
      return;
    }

    // set up order 
    let order = new Order();
    order.totalPrice = this.totalPrice;
    order.totalQuantity = this.totalQuantity;

    //get cart item 
    const cartItems = this.cartService.cartItem;


    //create order items from cart items 

    let orderItems: OrderItem[] = cartItems.map(item => new OrderItem(item));

    // setup purchase 

    let purchase = new Purchase();


    // populate purchase customer, 
    
    purchase.customer = this.checkoutFormGroup.controls['customer'].value;


    
    //shipping address, 

    purchase.shippingAddress = this.checkoutFormGroup.controls['shippingAddress'].value;
    const shippingState : State = JSON.parse(JSON.stringify(purchase.shippingAddress.state));
    const shippingCountry: Country = JSON.parse(JSON.stringify(purchase.shippingAddress.country));
    purchase.shippingAddress.state = shippingState.name;
    purchase.shippingAddress.country = shippingCountry.name;

        //billing address, 

        purchase.billingAddress = this.checkoutFormGroup.controls['billingAddress'].value;
        const billingState : State = JSON.parse(JSON.stringify(purchase.billingAddress.state));
        const billingCountry: Country = JSON.parse(JSON.stringify(purchase.billingAddress.country));
        purchase.billingAddress.state =billingState.name;
        purchase.billingAddress.country = billingCountry.name;
    

    //order and order items 

    purchase.order = order;
    purchase.orderItem = orderItems;



    // call rest api via check out service 

    this.checkoutService.placeOrder(purchase).subscribe(
      {
        next: response =>{
          alert(`your order has been received\n order tracking number: ${response.orderTrackingNumber}`);
               this.resetCart();
        },
        error: err => {
          alert(`there was an error :${err.message}`);
        }
      }


    );







  }

  resetCart(){
    // reset cart data 
    this.cartService.cartItem = [];
    this.cartService.totalPrice.next(0);
    this.cartService.totalQuantity.next(0);
    this.checkoutFormGroup.reset();
    this.router.navigateByUrl("/products");

  }

```


## there is a discrepency between cartitem and order item we need to make sure all the items should stay consistent with naming and type on spring boot backend !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!







